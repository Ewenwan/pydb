% $Id: libpydb.tex,v 1.22 2006/02/26 13:47:27 rockyb Exp $

% A note on labels. First, labels get used has HTML names if they don't
% have colons in them. Second, the last label inside a (sub)section will
% get used as a (sub)section head. Consequently we use colons for
% labels that aren't sections head and don't use colons if they are
% in a section head.

\chapter{The Extended Python Debugger \label{chapter-pydb}}

\declaremodule{standard}{pydb} \modulesynopsis{The Extended Python
debugger for interactive interpreters.}

The extended Python debugger builds on work done in the standard
\ulink{\module{Python
Debugger}}{http://docs.python.org/lib/module-pdb.html} ({\tt pdb.py}).

{\bf On \emph{not} inventing yet another interface}:\\
In extending the command set and functionality, we've used
\ulink{the GNU debugger}{http://www.gnu.org/software/gdb} ({\tt gdb})
as a guide for many reasons.

First the command set is likely to be complete, given its
longevity. Also, because of its longevity and pervasiveness, it is
likely to be more helpful to users---especially those that know {\tt
gdb} or my \ulink{GNU Bash debugger}{http://bashdb.sourceforge.net}
{\tt bashdb} or to some extent my \ulink{GNU Make
debugger}{http://bashdb.sourceforge.net/remake}. All of these follow
the same command interface and the learning curve is reduced for
people familiar with one of these; they are less likely to get
confused when switching between debuggers.

But it also has been helpful for other programs. I digress for a
little history.

When I first thought about adding the bash debugger into the GUI
interface \ulink{\code{ddd}}{http://www.ddd.org}, basically all I had
to do was tell \code{ddd} that handling this construct (e.g.,
stepping) is like \code{gdb}. There were a few places where I told \code{ddd}
not to follow \code{gdb} but Perl instead because the paradigm was
more like a scripting language than a compiled language. But in the
end, adding support for the bash debugger inside \code{ddd} was much more
straightforward and required much less thought than if I had invented
my own debugger command set.

After this was done and I fired up \code{ddd}, I noticed that, when my
cursor was hovering over some of the buttons, short descriptions for
the command were given. Furthermore there was a button called
``customize bash'' added setting variables inside. But I hadn't added
a box widget for customization or modified any code for using tool
tips. How did \code{ddd} do this?

Because I had copied the output format of \code{gdb}'s \samp{info},
\samp{set} and \samp{show} commands, \code{ddd} ran these commands on
its own and parsed the output; it then used that output to form tool
tips and create customization boxes.

In responses to a preliminary posting to \code{comp.lang.python}
asking why the Python debugger was different from other debuggers, a
number of people indicated that it didn't matter since they did not use
the standard Python debugger, or did not use it much.  To some extent,
I wonder if this is not a chicken-and-egg problem: is the debugger
lacking in usefulness because people don't use it much or do people
not use the debugger because it is lacking in usefulness?

I'm not sure, but if the standard Python debugger is little used,
keeping compatibility is not important.

So, in cases where the standard Python
debugger was incompatible with \code{gdb}, the \code{gdb} commands
have been used.

\section{Invoking the Debugger \label{pydb-invocation}}

Of the many additions to the standard Python debugger, two will be
mentioned here. First, this debugger should install itself somewhere
in your command path, usually as \code{pydb} so you don't have to
invoke it as an argument to the \code{python} command.

Second the extended debugger supports command switches courtesy of
\ulink{\module{optparse}}{http://docs.python.org/lib/module-optparse.html}.
In particular \code{pydb} has the two very common options
\samp{--help} to show what options are available and \samp{--version}
to report the version that is installed. 

These two options don't require any
further options. However usually you will want to give the name of a
script to debug and after that you may want to pass options for this
script.

Thus the general form of invoking the debugger is:

\code{pydb} \optional{\var{debugger-options}\ldots} \var{python-script} \optional{\var{script-options}\ldots}

A detailed list of options is given next.

\subsection{Debugger Command Options ({\tt --trace}, {\tt
    --output}, {\tt --command}, {\tt --nx}, \ldots)\label{subsection-switches}}

Many options have both a short and a long version. For example,
\samp{-x} is the short version while \samp{--command} is the long
version.

\begin{description} 

\item[--{}--batch]

Normally the debugger is entered before the debugged script is
executed. The user sets breakpoints or starts interactively stepping
through the program. However, if you want to start the script running
without any interactive behavior from the debugger, use this option
for example, if you know that a script will terminate with an
exception which causes the debugger to be entered at that point. The
\code{--trace} option implicitly sets this option.

\item[--{}--command=\var{filename}\code{\Large{|}}--x \var{filename}]\label{switch:command}

Run debugger script \var{filename}. This script is run after
the user's \code{.pydbrc} file.

\item[--{}--nx\code{\Large{|}}]\label{switch:nx}

Before execution is started, a debugger configuration file
\code{.pydbrc} is run. In some situations, for example regression
testing the debugger, you want to make sure that such configuration
files are not run and this option will do that.

\item[--{}--output=\var{filename}]

Write the normal output (\samp{stdout}) to the file
\var{filename}. Useful when running a Python script without access to
a terminal.

\item[--{}--error=\var{filename}]

Write the error output
(\samp{stderr}) to file \var{filename}. Useful in
 running a Python script without access to a terminal.

\item[--{}--trace]\label{switch:trace}

POSIX-style line tracing is available. In POSIX shells the short
option for this is \code{-x}; however since we follow \code{gdb}
conventions \code{-x} is used as a short option for
\code{--command}. When line tracing is turned on, each location (file
name and linenumber) is printed before the command is executed. This
option can be used in conjunction with the \code{--output} and
\code{--error} options described above when a terminal is not
available or when not running interactively. The corresponding
debugger command is \samp{set linetrace on}. See
\ref{command:linetrace} for more information.

\end{description}

\subsection{Startup files ({\tt .pydbrc})\label{subsection-startup-files}}

If a file \code{.pydbrc}
\indexii{.pydbrc}{file}\indexiii{debugger}{configuration}{file} exists
in the user's home directory or in the current directory, it is read
in and executed as if it had been typed at the debugger prompt.  This
is particularly useful for aliases.  If two files exist, the one in
the home directory is read first and aliases defined there can be
overridden by the local file. Finally you can specify a command file
to be read when invoking \code{pydb} and this is run last. See
\ref{switch:command} for information on how to run a command file.

Sometimes you may not want to run startup files. For example,
you may have a special installation script that uses the debugger and
want to make sure a user's profile doesn't get in the way. See
the \samp{--nx} command option, \ref{switch:nx}.

For tracking down problems with command files, see the \samp{set
cmdtrace on} debugger command, \ref{command:cmdtrace}.

\section{Debugger Commands \label{pydb-commands}}

In this section we describe debugger commands which can be used when
the debugger is run as a standalone program.

Most commands can be abbreviated to one or two letters;
e.g., \samp{h(elp)} means that either \samp{h} or \samp{help} can be
used to enter the help command (but not \samp{he}, \samp{hel},
\samp{H}, \samp{Help}, or \samp{HELP}).  Arguments to commands must
be separated by whitespace (spaces or tabs).  Optional arguments are
enclosed in square brackets (\samp{[]}) in the command syntax; the
square brackets must not be typed.  Alternatives in the command syntax
are separated by a vertical bar (\samp{|}).

Entering a blank line repeats the last command entered.  Exception: if
the last command was a \samp{list} command, the next 11 lines are
listed.

Commands that the debugger doesn't recognize are assumed to be Python
statements and are executed in the context of the program being
debugged.  Python statements can also be prefixed with an exclamation
point (\samp{!}).  This may be a good way to inspect the program being
debugged; it is even possible to change a variable or call a function.
When an exception occurs in such a statement, the exception name is
printed but the debugger's state is not changed.

The debugger supports aliases.  Aliases can have parameters which
allow a certain level of adaptability to the context under
examination. See \ref{command:aliases}.

{\bf Debugger Prompt}:\label{debugger:prompt}\\
By default the debugger's prompt string is \samp{(Pydb) } with 
a trailing blank. Recursive invocations using the
\samp{debug} command strip off the trailing blanks, add a layer of
parenthesis around the string, and add a trailing blank. For example,
for the default prompt the first debug invocation will be
\samp{((Pydb)) }.

\emph{There's currently a bug in the code where specified trailing
blanks are chopped. Furthermore the prompt may change in the future to
add a history number. It is generally not advisable to change the
prompt.}

If you do need to change the prompt see
\ref{command:prompt}.


Multiple commands may be entered on a single line, separated by
\samp{;;}.  (A single \samp{;} is not used because it is
the separator for multiple commands in a line that is passed to
the Python parser.)
No intelligence is applied to separating the commands;
the input is split at the first \samp{;;} pair, even if it is in
the middle of a quoted string.

\subsection{Status and Debugger Settings ({\tt set}, {\tt show}, {\tt info})\label{subsection-status}}

A {\tt set} command modifies parts of the debugger environment. You can
see these environment settings with the {\tt show} command.  An {\tt
info} command shows things about the program being debugged.

\subsubsection{Set ({\tt set})\label{subsubsection-set}}

In all of the set options that take ``on'' or ``off'' parameters, you
can also use 1 for ``on'' and 0 for ``off.''

Each command has a corresponding {\tt show} command to show the current
value. See \ref{subsubsection-show} for these counterparts.

\begin{description}

\item[set basename on\code{\Large{|}}off]\label{command:basename}

When showing filenames print only the basename. This option is useful
in regression testing where the base file names are the same
on different installations even though the directory path may
be different. You may want to use this in other
situtations as well, like showing a debugger session in a manual
such as this one. 

\item[set cmdtrace on\code{\Large{|}}off]\label{command:cmdtrace}
 
Show lines as they are read from the debugger command file (or
\samp{source} debugger command). This is useful in running
regression tests, but it may be helpful in tracking down a problem in
your \code{.pydbrc} file.

\item[set linetrace on\code{\Large{|}}off]\label{command:linetrace}

If this is set on, the position (file and linenumber) is shown before
executing a statement. By default this is off. Using the command-line
option \samp{--trace} when invoking \code{pydb} implicitly sets this
on.  For information on \samp{--trace}, see \ref{switch:trace}.

Using this option will slow down your
program. Unless single stepping through a program, normally the
debugger is called only at breakpoints or at the call and return of a
function or method. However when line tracing is turned on, the
debugger is called on execution of every statement. 

That said, execution may still be pretty fast. If you want to slow
down execution further, see the following option.

\item[set linetrace delay \var{time}]\label{command:linetrace-delay}

One of the useful things you can do with this debugger if you run it
via a front-end GUI is watch your program as it executes. To do this,
use \samp{set linetrace on} which prints the location before each
Python statement is run. Many front-end GUIs like the one in GNU Emacs
and \code{ddd} will read the location and update the display
accordingly.

There is however one catch---Python runs too fast. So by using this
option you can set a delay after each statement is run in order for
GNU and your eyes to catch up with Python. Specify a floating
point indicating the number of seconds to wait. For example: 

\begin{verbatim}
set linetrace delay 0.5 # 1/2 a second
\end{verbatim}

In my experience half a second is about right.

\item[set listsize \var{lines}]\label{command:listsize}

Sets how many lines are shown by the \code{list} command. See
\ref{command:list}.

\item[set prompt \var{prompt-string}]\label{command:prompt}

Set debugger's prompt string. By default it is \samp{(Pydb) } with
a trailing space. For information on how the prompt
changes, see \ref{debugger:prompt}.

\emph{There's currently a bug in the code where specified trailing
blanks specified. Furthermore the prompt may change in the future to
add a history number. It is generally not advisable to change the
prompt.}

\end{description}

\subsubsection{Show ({\tt show}) \label{subsubsection-show}}

All of the ``show'' commands report some sort of status and all have a
corresponding ``set'' command to change the value. See
\ref{subsubsection-set} for the ``set'' counterparts.

\begin{description}

\item[show args]

Show the argument list that was given the program being debugged or it is
restarted

\item[show basename]

Show short or long filenames

\item[show cmdtrace]

Show the debugger commands before running

\item[show linetrace]

Show the line tracing status

\item[show linetrace delay]

Show the delay after tracing each line

\item[show listsize]

Show the number of source lines \code{gdb} will list by default

\item[show prompt]

Show the current debugger prompt

\item[show version]

Show the debugger version number

\end{description}

\subsubsection{Info ({\tt info})\label{subsubsection-info}}

Running this command without parameters will print the list of
available info commands. Below is a description of the individual
commands.

\begin{description}

\item[info args]

Show function/method parameters. See \ref{command:info-args}.

\item[info break]

Show the list of breakpoints. 

\item[info globals]

Show the global variables. See \ref{command:info-globals}. 

\item[info line]

Show the current line number in source file. If a function name is
given, the starting line of the function is reported.

\item[info locals]

Show the local variables. See \ref{command:info-locals}. 

\item[info program]

Show the execution status of the program. The possible status is that
the program is not running (e.g. in post-mortem dump), or the program is
``stoppped'' and if stopped at a breakpoint that is shown as well.

\item[info source]

Information about the current Python file.

\end{description}

\subsection{Breakpoints ({\tt break}, {\tt tbreak}, {\tt clear},
  {\tt delete}, {\tt disable}, {\tt
  ignore})\label{subsubsection-brkpts}}

\index{breakpoints} A breakpoint makes your program stop at that
point. You can add conditions for each breakpoint.  You can set
breakpoints with the \code{break} command and its variants. You can specify
the place where your program should stop by file and line number or by
function name.

The debugger assigns a number to each breakpoint when you create it;
these numbers are successive integers starting with 1.  In many of the
commands for controlling various features of breakpoints you use this
number.  Each breakpoint may be enabled or disabled; if disabled, it
has no effect on your program until you enable it again.

The debugger allows you to set any number of breakpoints at the same
place in your program.  There is nothing unusual about this because
different breakpoints can have different conditions associated with them.

\begin{description}
\item[b(reak) \optional{\optional{\var{filename}:}\var{lineno}\code{\Large{|}}\var{function}\optional{, \var{condition}}}]

With a \var{lineno} argument, set a break at that line number in the
current file.  With a \var{function} argument, set a break at the
first executable statement within that function.  The line number may
be prefixed with a filename and a colon to specify a breakpoint in
another file (probably one that hasn't been loaded yet).  The file is
searched on \code{sys.path}.  Note that each breakpoint is assigned a
number to which all the other breakpoint commands refer.

If a second argument is present, it is an expression which must
evaluate to true before the breakpoint is honored.

Without an argument, list all breaks, including for each breakpoint:
the number of times that breakpoint has been hit, the current
ignore count, and the associated condition if any.

\item[tbreak \optional{\optional{\var{filename}:}\var{lineno}\code{\Large{|}}\var{function}\optional{, \var{condition}}}]

Temporary breakpoint, which is removed automatically when it is
first hit.  The arguments are the same as those for \code{break}.

\item[cl(ear) \optional{\optional{\var{filename}:}\var{lineno}\code{\Large{|}}\var{function}}]

Clear breakpoint at specified line or function.  Argument may be line
number, function name, or `*' and an address.  If a line number is
specified, all breakpoints in that line are cleared.  If a function is
specified, the breakpoints at the beginning of the function are cleared.  If an
address is specified, breakpoints at that address are cleared.

With no argument, clears all breakpoints in the line where the selected
frame is executing.

See also the \code{delete} command below which clears breakpoints by
number.

\item[delete \optional{\var{bpnumber} \optional{\var{bpnumber \ldots}}}]

With a space-separated list of breakpoint numbers, clear those
breakpoints.  Without argument, clear all breaks (but first
ask confirmation).

\item[disable \optional{\var{bpnumber} \optional{\var{bpnumber \ldots}}}]

Disable the breakpoints given as a space-separated list of
breakpoint numbers.  Disabling a breakpoint means it cannot cause
the program to stop execution, but unlike clearing a breakpoint, it
remains in the list of breakpoints and can be (re-)enabled.

\item[enable \optional{\var{bpnumber} \optional{\var{bpnumber \ldots}}}]

Enable the breakpoints specified.

\item[ignore \var{bpnumber} \optional{\var{count}}]

Set the ignore count for the given breakpoint number.  If count is
omitted, the ignore count is set to 0.  A breakpoint becomes active
when the ignore count is zero.  When non-zero, the count is
decremented each time the breakpoint is reached, the breakpoint is not
disabled, and any associated condition evaluates to true.

\item[condition \var{bpnumber} \optional{\var{condition}}]

Condition is an expression which must evaluate to true before
the breakpoint is honored.  If condition is absent, any existing
condition is removed; i.e., the breakpoint is made unconditional.

\end{description}

\subsection{Resuming Execution ({\tt step}, {\tt next}, {\tt
    finish}, {\tt return} {\tt continue}, {\tt jump})\label{subsubsection-resume}}

``Continuing'' means resuming program execution until the program
completes normally.  In contrast, ``stepping'' means executing just
one statement of the program. When continuing or stepping, the program may stop even sooner, due to a breakpoint or an
exception.

\begin{description}

\item[s(tep) \optional{\var{count}}]\label{command:step}

Execute the current line, stop at the first possible occasion
(either in a function that is called or on the next line in the
current function).

\item[n(ext) \optional{\var{count}}]\label{command:next}

Continue execution until the next line in the current function
is reached or the function returns.  The difference between \samp{next} and
\samp{step} is that \samp{step} stops inside a called function, while
\samp{next} executes called functions at (nearly) full speed, 
stopping only at the next line in the current function.

\item[finish]\label{command:finish}

Continue execution until the current function returns.
that point the \samp{retval} command can be used to show the
return value. The short command name is rv.

See also \ref{command:retval} and \ref{command:return}.

\item[return]\label{command:return}

Make selected stack frame return to its caller. Control remains in the
debugger, but when you continue execution will resume at the return
statement found inside the subroutine or method.  At present we are
only able to perform this if we are in a subroutine that has a
\code{return} statement in it.  See also \ref{command:retval} and
\ref{command:finish}

\item[c(ont(inue))]

Continue execution, stop only when a breakpoint is encountered.

\item[j(ump) \var{lineno}]

Set the next line that will be executed. available only in the
bottom-most frame.  This lets you jump back and execute code
again, or jump forward to skip code that you don't want to run.

Not all jumps are allowed---for instance it
is not possible to jump into the middle of a \keyword{for} loop or out
of a \keyword{finally} clause.

\end{description}

\subsection{Examining Call Frames ({\tt info args}, {\tt info
    locals}, {\tt up}, {\tt down}, {\tt frame})\label{subsection-frames}}

Each line in the backtrace shows the frame number and the function
name, if it exists and the place in a file where the statement is
located.

Here is an example of a backtrace from a sample Towers of Hanoi
program that is used in regression testing:

\begin{verbatim}
## 0 hanoi() called from file '/tmp/pydb/test/hanoi.py' at line 5
-> 1 hanoi() called from file '/tmp/pydb/test/hanoi.py' at line 6
## 2 in file '/tmp/pydb/test/hanoi.py' at line 29
## 3 in file '<string>' at line 1
## 4 run() called from file '/usr/lib/python2.4/bdb.py' at line 366
\end{verbatim}

The {\tt->} arrow indicates the focus. In the example, I issued an
\samp{up} command which is why the focus is on 1 rather than 0 as it
would normally be after a stop.

There are two ``hanoi'' frames listed because this is a hanoi called
itself recursively. In frame 2 and 3 we don't have a function name
listed. That's because there is none. Furthermore in frame 3 there is
a funny ``in file {\tt '<string>'} at line 1.'' That's because there
isn't even a file assocated with the command. The command issued:

\begin{verbatim}
   exec cmd in globals, locals
\end{verbatim}

This statement can be seen in frame 4. This is a bug which I hope to
fix with a more informative message.

Finally, note that frames 2 and 3 really are not part of the
program to be debugged but are part of the internal workings of the
debugger. It's possible to hide this, but in the open spirit of Python
for now it hasn't been hidden.

\begin{description}

\item[info args]\label{command:info-args}

Show the method or function parameters and their values. 

Here is an example of the output for the backtrace of the hanoi
program shown at the beginning of this section:

\begin{verbatim}
(Pydb) info args
n= 3
a= a
b= b
c= c
(Pydb) 
\end{verbatim}

\item[info locals]\label{command:info-locals}

Show all local variables for the given stack frame. This will include
the variables that would be shown by \samp{info args}.

\item[where\code{\Large{|}}T\code{\Large{|}}bt \optional{\var{count}}]

Print a backtrace, with the most recent frame at the top.  An
arrow indicates the current frame, which determines the context of
most commands.

With a positive number \var{count}, print at most many entries.

An example of a backtrace is given at the beginning of this section.

\item[retval\code{\Large{|}}rv]\label{command:retval}

Show the value that will be returned by the current function. This
command is meaningful only just before a return (such as you'd get
using the \code{finish} or \code{return} commands) or stepping after a
return statement.

To change the value, make an assignment to the variable
\code{__return__}.

See also \ref{command:finish}.

\item[d(own) \optional{\var{count}}]

Move the current frame one level down in the stack trace
(to a newer frame). With a count, which can be  positive
or  negative, move that many positions.

\item[u(p) \optional{\var{count}}]

Move the current frame one level up in the stack trace (to an older
frame). With a count, which can be positive or negative,
move that many positions.

\item[frame \optional{\var{position}}]
Move the current frame to the specified frame number. A negative
number indicates position from the end, so \code{frame -1} moves to 
the newest frame, and \code{frame 0} moves to the oldest frame.

\end{description}

\subsection{Examining Data ({\tt print}, {\tt pprint}, {\tt examine}, {\tt info globals})\label{subsection-data}}

\begin{description}

\item[display \optional{\var{format}} \var{expression}]

Print value of expression \var{expression} each time the program
stops.  \var{format} may be used before \var{expression} as in the
"print" command.  \var{format} "i" or "s" or including a size-letter
is allowed, and then \var{expression} is used to get the address to
examine.

With no argument, display all currently requested auto-display
expressions.  Use "undisplay" to cancel display requests previously
made.

\item[undisplay \optional{\var{format}} \var{expression}]

Evaluate the \var{expression} in the current context and print its
value.  \note{\samp{print} can also be used, but is not a debugger
command---it executes the Python \keyword{print} statement.}


\item[p \var{expression}]

Evaluate the \var{expression} in the current context and print its
value.  \note{\samp{print} can also be used, but is not a debugger
command---it executes the Python \keyword{print} statement.}

\item[pp \var{expression}]

Like the \samp{p} command, except the value of the expression is
pretty-printed using the \module{pprint} module.

\item[examine \var{expression}]

Print the type of the expression and pretty-print its value.  For
functions, methods, classes, and modules print out the documentation
string if any.  For functions also show the argument list.

The examine debugger command in Perl is the model here, however much
more work is needed. Note that \samp{x} is not a short name for
``expression'' (as it is in Perl's debugger), although you could
easily make it be via an alias.

\item[info globals]\label{command:info-globals}

Show all global variables. These variables are not just the variables
that a programs sees via a \code{global} statement, but all of them
that can be accessible.

\end{description}

\subsection{Running Arbitrary Python Commands ({\tt debug}, {\tt !})\label{subsection-commands}}

\begin{description}

\item[\optional{!}\var{statement}]

Execute the (one-line) \var{statement} in the context of
the current stack frame.
The exclamation point can be omitted unless the first word
of the statement resembles a debugger command.
To set a global variable, you can prefix the assignment
command with a \samp{global} command on the same line, e.g.:

\begin{verbatim}
(Pydb) global list_options; list_options = ['-l']
(Pydb)
\end{verbatim}

\item[debug \var{statement}]

Enter a recursive debugger that steps through the code argument (which
is an arbitrary expression or statement to be executed in the current
environment). The prompt is changed to indicate nested behavior. See
\ref{debugger:prompt}

\end{description}

\subsection{Debugging a Python Script ({\tt restart}, {\tt run})\label{subsection-restart}}

\begin{description}

\item[restart \var{args...}]

Restart debugger and program via an \code{exec} call. All state
is lost, and new copy of the debugger is used.

\item[run \var{args...}]

Run or restart the debugged Python program. If a string is supplied
that becomes the new command arguments.  History, breakpoints, actions
and debugger options are preserved.  \code{R} is a short command alias
for run.

\end{description}

\subsection{Interfacing to the OS ({\tt shell}, {\tt pwd},
  {\tt cd})\label{subsection-os}}

\begin{description}

\item[cd \var{directory}]

Set working directory to \var{directory} for debugger and program
being debugged.

\item[pwd]

Print working directory.  

\item[shell \var{statement}]

Execute the rest of the line as a shell command.


\end{description}

\subsection{Listing Program Code ({\tt list}, {\tt disassemble})\label{subsection-listing}}

\begin{description}

\item[disassemble \optional{\var{arg}}]

With no argument, disassemble at the current frame location.  With a
numeric argument, disassemble at the frame location at that line
number. With a class, method, function, code or string argument,
disassemble that.

\item[l(ist) \optional{\var{first}\optional{, \var{last}}}]\label{command:list}

List source code for the current file.  Without arguments, list
\emph{n} lines around the current line or continue the previous
listing, where \emph{n} is the value set by \samp{set listsize} or
shown by \samp{show listsize}.  The default value is 10.

With one argument, list \emph{n} lines around that line.  With
two arguments, list the given range; if the second argument is less
than the first, it is interpreted as a count.

\end{description}

\subsection{Miscellaneous Commands ({\tt help}, {\tt quit}, {\tt
    alias}, {\tt unalias})\label{subsection-misc}}

\begin{description}

\item[h(elp) \optional{\var{command} \optional{subcommand}}]

Without argument, print the list of available commands.  With
\var{command} as argument, print help about that command.  \samp{help
pydb} displays the full documentation file; if the environment
variable \envvar{PAGER} is defined, the file is piped through that
command.  Since the \var{command} argument must be an identifier,
\samp{help exec} must be entered to get help on the \samp{!} command.

Some commands, \code{info}, \code{set}, and \code{show} can accept an
additional subcommand to give help just about that particular
subcommand. For example \code{help info line} give help about the
\code{info line} command.

\item[alias \optional{\var{name} \optional{command}}]\label{command:aliases}

Create an alias called \var{name} that executes \var{command}.  The
command must not be enclosed in quotes.  Replaceable parameters
can be indicated by \samp{\%1}, \samp{\%2}, and so on, while \samp{\%*} is
replaced by all the parameters.  If no command is given, the current
alias for \var{name} is shown. If no arguments are given, all
aliases are listed.

Aliases may be nested and can contain anything that can be legally
typed at the \code{pydb} prompt.  Note that internal \code{pydb}
commands can be overridden by aliases.  Such a command is then hidden
until the alias is removed.  Aliasing is recursively applied to the
first word of the command line; all other words in the line are left
alone.

As an example, here are two useful aliases (especially when placed
in the \code{.pydbrc} file):

\begin{verbatim}
#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]
#Print instance variables in self
alias ps pi self
\end{verbatim}
                
\item[unalias \var{name}]

Delete the specified alias.

\item[q(uit)]

Quit the debugger. The program being executed is aborted. For now,
\code{kill} is a synonym for quit.

\end{description}

\section{The Debugger Module (\module{pydb}) and Class (\class{Pdb}) \label{pydb-module-class}}

The module \module{pydb} defines an interactive source code
debugger\index{debugging} for Python programs.  It supports setting
(conditional) breakpoints and single stepping at the source-line
level, inspection of stack frames, source-code listing, and evaluation
of arbitrary Python code in the context of any stack frame.  It also
supports disassembly of code and post-mortem debugging and can be
called under program control.

The debugger is extensible---it is defined as the class
\class{Pdb}\withsubitem{(class in pydb)}{\ttindex{Pdb}}.  This is
currently undocumented but easily understood by reading the source.
The extension interface uses the modules
\module{bdb}\refstmodindex{bdb} (undocumented) and
\refmodule{cmd}\refstmodindex{cmd}.

All of the methods intended for outside use are documented. In fact
the help documentation for commands comes from the document strings of
the corresponding methods.

One group of methods that may be useful to subclass would be the
output methods \method{errmsg}, \method{msg}, and
\method{msg_nocr}. In early regression development I subclassed these
so that I could capture debugger output. It turned out, however, that
I needed far too many tests and working this way would not scale.

\subsection{Cmd Inheritance}
Because \class{Pdb} inherts from \class{Cmd}, the following
conventiions are used. 

All of the debugger commands listed in \ref{command:debugger} are methods
of a Pdb object. The method names are the command name prefixed by
\code{do_}. For example the method handling the \samp{step} command is
\code{do_step}, and the command handling the \samp{frame} command is
\code{do_frame}. 


\subsection{Calling the debugger from inside your program}

By issuing \code{pydb} you are actually running another program first
which is then invokes your script. \code{pydb} tries hard to make
itself transparent and does things such as resetting \code{sys.argv}
and \code{__file__} to the values you would get by calling the
debugged program directly.

However there are times when this doesn't work right. (And clearly at
present I don't know how to fix or else I would.)

So another approach which doesn't have this complexity or drawback is
too add a call to the debugger at special places. For this, the
\code{pydb} function \code{set_trace()} can be used. For example:

\begin{verbatim}
import pydb
... some code
pydb.set_trace() 
more_code() # debugger will show this line to be executed
...
\end{verbatim}

When \code{pydb.set_trace()} function is called, the program stops
before the next statement. 

To continue running the program, issue a debugger \code{next},
\code{step} or a \code{continue} command.

The exit the program use the \code{quit} or a termanal EOF.

\subsection{Other alternative methods of invocation}

With the caveat mentioned in the previous section, I think most people
will probably use the \code{pydb} command described in
\ref{pydb-invocation}. However for completeness here we give some
other alternatives.

Here's another way run a program under control of the debugger:

\begin{verbatim}
>>> import pydb
>>> import mymodule
>>> pydb.run('mymodule.test()')
(<string>:1): 
(/usr/lib/python2.4/bdb.py:366):  run
(Pydb) continue
\end{verbatim}

\subsection{Post-Mortem Debugging}

When invoked as a script, \code{pydb} will automatically enter
post-mortem debugging if the program being debugged exits
abnormally. After post-mortem debugging (or after normal exit of the
program), \code{pydb} will restart the program.  Automatic restarting
preserves \code{pydb}'s state (such as breakpoints) and in most cases is more
useful than quitting the debugger upon the program's exit.
\versionadded[Restarting post-mortem behavior]{2.4}

It is also possible to get post-mortem debugging even if \code{pydb}
was not initially run as a script. 

Here is an example of using \code{pydb} after program crashes and
gives a traceback:

\begin{verbatim}
>>> import sys
>>> import mymodule
>>> mymodule.test()
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "./mymodule.py", line 4, in test
    test2()
  File "./mymodule.py", line 3, in test2
    print spam
NameError: spam
>>> import pydb
>>> pydb.pm()
> (./mymodule.py:3):  test2
-> print spam
(Pydb) 
\end{verbatim}

It is important to have \code{sys} imported so that the traceback is
saved in \code{sys.last_traceback}. Alas, at present if you are using
\code{ipython}, that captures the exception and
\code{sys.last_traceback} will not be defined. 

If you have a traceback stored say in variable \code{t}, instead of 
\code{pydb.pm()} above, use \code{pydb.post_mortem(t)}.

\subsection{debugger entry functions}

The \code{pydb} module defines the following functions, and each enters
the debugger in a slightly different way:

\begin{funcdesc}{pm}{}
Enter post-mortem debugging of the traceback found in
\code{sys.last_traceback}. Note you may need to have \code{sys}
imported priort to having the error raised to have sys.last_traceback
set.

To set debugger options, pass a dictionary of variable, value pairs
that you want set in \var{opts-dictionary}. For example if you want
the display listsize to be 20 by default on entry pass
\code{@{listsize: 20@}}.
\end{funcdesc}

\begin{funcdesc}{post_mortem}{traceback\optional{opts-dictionary=None}}
Enter post-mortem debugging of the given \var{traceback} object.

To set debugger options, pass a dictionary of variable, value pairs
that you want set in \var{opts-dictionary}. For example if you want
the display listsize to be 20 by default on entry pass
\code{@{listsize: 20@}}.

\end{funcdesc}

\begin{funcdesc}{run}{statement\optional{, globals\optional{, locals}}}
Execute the \var{statement} (given as a string) under debugger
control.  The debugger prompt appears before any code is executed; you
can set breakpoints and type \samp{continue}, or you can step through
the statement using \samp{step} or \samp{next} See \ref{command:step}
and \ref{command:next} for explanations of these commands.  The
optional \var{globals} and \var{locals} arguments specify the
environment in which the code is executed; by default the dictionary
of the module \refmodule[main]{__main__} is used.  (See the
explanation of the \keyword{exec} statement or the \function{eval()}
built-in function.)
\end{funcdesc}

\begin{funcdesc}{runcall}{function\optional{, argument, ...}}
Call the \var{function} (a function or method object, not a string)
with the given arguments.  When \function{runcall()} returns, it returns
whatever the function call returned.  The debugger prompt appears as
soon as the function is entered.
\end{funcdesc}

\begin{funcdesc}{runeval}{expression\optional{, globals\optional{, locals}}}
Evaluate the \var{expression} (given as a string) under debugger
control.  When \function{runeval()} returns, it returns the value of the
expression.  Otherwise this function is similar to
\function{run()}.
\end{funcdesc}

\begin{funcdesc}{set_trace}{}
Enter the debugger at the calling stack frame.  This is useful to
hard-code a breakpoint at a given point in a program, even if the code
is not otherwise being debugged (e.g., when an assertion fails).

When the debugger is quitting, this causes the program to be
terminated. If you want the program to continue instead, use the
\code{debugger} function.

\end{funcdesc}

\section{How the Debugger Works \label{debugger-hooks}}

Some changes were made to the interpreter:

\begin{itemize}
\item \code{sys.settrace(\var{func})} sets the global trace function
\item there can also be a local trace function (see below)
\end{itemize}

Trace functions have three arguments: \var{frame}, \var{event}, and
\var{arg}. \var{frame} is the current stack frame.  \var{event} is a
string: \code{'call'}, \code{'line'}, \code{'return'}, \code{'exception'},
 \code{'c_call'}, \code{'c_return'}, or \code{'c_exception'}. \var{arg}
 depends on the event type.

The global trace function is invoked (with \var{event} set to
\code{'call'}) whenever a new local scope is entered; it returns
a reference to the local trace function to be used in that scope, or
\code{None} if the scope couldn't be traced.

The local trace function  returns a reference to itself (or to
another function for further tracing in that scope), or \code{None} to
turn off tracing in that scope.

Instance methods are accepted (and very useful) as trace functions.

The events have the following meanings:

\begin{description}

\item[\code{'call'}]
A function is called (or some other code block entered).  The global
trace function is called; \var{arg} is \code{None};
the return value specifies the local trace function.

\item[\code{'line'}]
The interpreter is about to execute a new line of code (sometimes
multiple line events on one line).  The local trace function is
called; \var{arg} is \code{None};\ the return value specifies the new
local trace function.

\item[\code{'return'}]
A function (or other code block) is about to return.  The local trace
function is called; \var{arg} is the value that will be returned.  The
trace function's return value is ignored.

\item[\code{'exception'}]
An exception has occurred.  The local trace function is called;
\var{arg} is a triple \code{(\var{exception}, \var{value},
\var{traceback})};\ the return value specifies the new local trace
function.

\item[\code{'c_call'}]
A C function is about to be called.  This may be an extension function
or a builtin.  \var{arg} is the C function object.

\item[\code{'c_return'}]
A C function has returned. \var{arg} is \code{None}.

\item[\code{'c_exception'}]
A C function has thrown an exception.  \var{arg} is \code{None}.

\end{description}

Since an exception is propagated down the chain of callers, an
\code{'exception'} event is generated at each level.

For more information on code and frame objects, see to the
\ulink{Python Reference
Manual}{http://docs.python.org/ref/ref.html}.
