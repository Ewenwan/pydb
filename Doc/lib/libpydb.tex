\chapter{The Extended Python Debugger \label{extdebugger}}

\declaremodule{standard}{pydb}
\modulesynopsis{The Extended Python debugger for interactive
  interpreters.}

The ``extended'' Python debugger builds on work done in the standard
\ulink{\module{Python
Debugger}}{http://docs.python.org/lib/module-pdb.html} ({\tt pdb.py}).

However in filling out the command set and functionality, we've used
\ulink{the GNU debugger}{http://www.gnu.org/software/gdb} ({\tt gdb})
as a guide.

{\bf On \emph{not} inventing yet another interface}:\\
There are many benefits. First the command set is likely to be
complete, given its longevity. Also because of its longevity, and
pervasiveness it is likely to be more helpful to users---especially
those that know {\tt gdb} or my \ulink{GNU Bash
debugger}{http://bashdb.sourceforge.net} {\tt bashdb} or to some
extent my \ulink{GNU Make
debugger}{http://bashdb.sourceforge.net/remake}. All of these also
follow that command interface and for folks that know one of these,
the learning curve is reduced, and are less likely to get confused
when switching between debuggers.

But it also has been helpful for other programs! I digress for a
little parable.

When I first thought about adding the bash debugger into the GUI
interface \ulink{\code{ddd}}{http://www.ddd.org}, basically all I had
do do was tell \code{ddd} that handling this construct (e.g. stepping)
is like gdb. There were a few places where I told \code{ddd} not to
follow \code{gdb} but Perl instead because the paradigm had to be more
like a scripting language than a compiled language. But in the end,
adding support for the bash debugger inside ddd was much more
straightforward and required much less thought than if I had invented
my own debugger command set.

After this was done and I fire up \code{ddd}, I noticed that when my
cursor was hovering over some of the buttons short descriptions for
the command were given. Furthermore there was this button called
``customize bash'' added and in that there are all these setting
variables. But I didn't remember adding a box widget for customization
or remember modifying any code for using tool tips. How did \code{ddd} do
this? I was very curious and had to find out.

Because I even copied the output format of gdb's ``info'', ``set'' and
``show'' commands, \code{ddd} ran these commands on its own and parsed
the output; it then used that output to form tool tips and create a
customization boxes!

In a preliminary posting to \code{comp.lang.python} asking why the
python debugger was different than other debuggers, a number of people
indicated that it didn't matter as they did not use standard Python
debugger, or use it much.  To some extent, I wonder if this is not a
chicken-and-egg problem: is the debugger is lacking in usefulness
because folks don't use it much or do people not use the is the
debugger because it is lacking in usefulness.

I'm not sure, but one I think does seem more clear. If the standard
Python debugger is used little, keeping compatibility can't be all
that important---at least for those people who volunteered they don't
use a debugger in Python.

Thus in light of the above, in cases where the standard Python
debugger was incompatible with \code{gdb}, the \code{gdb} commands
have been used.

\section{Invoking the Debugger \label{debugger-switches}}

There are two extensions over the standard Python debugger that we've
provided. First, this debugger should install itself somewhere in your
command path, usually as \code{pydb}. So you don't have to invoke it
as an argument to the \code{python} command.

Second the extended debugger supports command switches courtesy of
\ulink{\module{optparse}}{http://docs.python.org/lib/module-optparse.html}.
In particular \code{pydb} has the two very common options
\samp{--help} to show what options are available and \samp{--version}
to show report the version that is use. 

These two options are complete in of themselves and don't require any
futher options. However usually you will want to give a the name of a
script to debug and after that you may want to pass options for this
script.

Thus the general form of invoking the debugger is:

\file{pydb} \optional{\var{debugger-options}\ldots} \var{python-script} \optional{\var{script-options}\ldots}

A detailed list of options is given next.

\subsection{Debugger Command Options ({\tt --linetrace}, {\tt
    --output}, {\tt --command}, {\tt --nx}, \ldots)\label{subsection:command-options}}

Many options have both a short name version and a long name
option. For example, \samp{--command} is the long command-name option
while and \samp{-x} is the short command-name option.

\begin{description} 

\item[--{}--batch]

Normally the debugger is entered before the debugged script is
executed. If you want to initally start the script running, use this
option. For example, if you know that a script will terminate with an
exception which causes the debugger to be entered at that point, you
may want to use this option. The \code{--linetrace} option implicitly
sets this option.

\item[--{}--command=\var{filename}\code{\Large{|}}--x \var{filename}]\label{switch:command}

Run debugger script \var{filename}. Note that this script is run
\emph{after} the user's \file{.pydbrc} file.

\item[--{}--nx\code{\Large{|}}]\label{switch:nx}

Before execution is started, a debugger configuration file
\file{.pydbrc} is run. In some situations, for example regression
testing the debugger, one wants to make sure that such configuration
files are \emph{not} run and this option will do that.

\item[--{}--output=\var{filename}]

If you want to have the debugger write it's normal output
(\samp{stdout}) to file \var{filename}, use this option. Useful in
situations where is running a Python script but one doesn't have
access to a terminal.

\item[--{}--error=\var{filename}]

If you want to have the debugger write it's error output
(\samp{stderr}) to file \var{filename}, use this option. Useful in
situations where is running a Python script but one doesn't have
access to a terminal.

\item[--{}--trace]\label{switch:trace}

POSIX-style line tracing is available. In POSIX shells the short
option for this is \code{-x}; however since we follow \code{gdb}
conventions \code{-x} is used as a short option for
\code{--command}. When line tracing is turned on, each location (file
name and linenumber) is printed before the command is executed. This
option can be used in conjuntion with the \code{--output} and
\code{--error} options described above situations where a terminal is
not available or where one interactive attendence is unavailable or
not desired. The corresponding debugger command is \samp{set linetrace
on}. See \ref{command:linetrace} for more information.

\end{description}

\subsection{Startup files ({\tt .pydbrc})\label{subsection:startup-files}}

If a file \file{.pydbrc}
\indexii{.pydbrc}{file}\indexiii{debugger}{configuration}{file} exists
in the user's home directory or in the current directory, it is read
in and executed as if it had been typed at the debugger prompt.  This
is particularly useful for aliases.  If both files exist, the one in
the home directory is read first and aliases defined there can be
overridden by the local file. Finally one can specify a command file
to be read when invoking \code{pydb} and this is run last. See
\ref{switch:command} for information how to run a command file.

Sometimes you may \emph{not} want startup files are run. For example,
you may have a special installation script that uses the debugger and
want to make sure a user's profile doesn't get in the way. Here you
may want to refer to the \samp{--nx} command option when starting
\code{pydb}. See \ref{switch:nx}.

For tracking down problems with command files, the \samp{set
cmdtrace on} debugger command may be of interest. See
\ref{command:cmdtrace} for details on that.

\section{Debugger Commands \label{command:debuggers}}

In this section we describe debugger commands which can be used when
the debugger is run as a standalone program.

Most commands can be abbreviated to one or two letters;
e.g. \samp{h(elp)} means that either \samp{h} or \samp{help} can be
used to enter the help command (but not \samp{he} or \samp{hel}, nor
\samp{H} or \samp{Help} or \samp{HELP}).  Arguments to commands must
be separated by whitespace (spaces or tabs).  Optional arguments are
enclosed in square brackets (\samp{[]}) in the command syntax; the
square brackets must not be typed.  Alternatives in the command syntax
are separated by a vertical bar (\samp{|}).

Entering a blank line repeats the last command entered.  Exception: if
the last command was a \samp{list} command, the next 11 lines are
listed.

Commands that the debugger doesn't recognize are assumed to be Python
statements and are executed in the context of the program being
debugged.  Python statements can also be prefixed with an exclamation
point (\samp{!}).  This is a powerful way to inspect the program being
debugged; it is even possible to change a variable or call a function.
When an exception occurs in such a statement, the exception name is
printed but the debugger's state is not changed.

The debugger supports aliases.  Aliases can have parameters which
allows one a certain level of adaptability to the context under
examination. See \ref{command:aliases}.

{\bf Debugger Prompt}:\label{debugger-prompt}\\
By default the debugger's prompt string is \samp{(Pydb) }. There
is a trailing space in there. Recursive invocations using the
\samp{debug} command, strip off the trailing blanks, add a layer of
parenthesis around the string and add a trailing blank. For example,
for the default prompt the first debug invocation will be
\samp{((Pydb)) }.

\emph{There's currently a bug in the code where trailing blanks
specified are chopped. Furthermore the prompt may change in the future
to add a history number. Unless you have good reason to, it is
generally not advisable to change to prompt.}

Having said this, if you do need to change the prompt see
\ref{command:prompt}.


Multiple commands may be entered on a single line, separated by
\samp{;;}.  (A single \samp{;} is not used as it is
the separator for multiple commands in a line that is passed to
the Python parser.)
No intelligence is applied to separating the commands;
the input is split at the first \samp{;;} pair, even if it is in
the middle of a quoted string.

\subsection{Status and Debugger Settings ({\tt set}, {\tt show}, {\tt info})}

\subsubsection{Set ({\tt set})\label{subsubsection:set}}

In all of the set options decscribed below that take ``on'' or ``off''
parameters, you can also use 1 for ``on'' and 0 for ``off''

\begin{description}

\item[set basename on\code{\Large{|}}off]

When showing filenames just print the basename. This option is useful
in regression testing where the the ``base'' file names are the same
on different installations even though the actually directory path may
be different. It is possible you may want to use this in other
situtations as well, such as showing a debugger session in a manual
such as this one. 

\item[set cmdtrace on\code{\Large{|}}off]\label{command:cmdtrace}
 
Set to show lines as they are read from debugger command file (or
\samp{source} debugger command). This is useful in running
regression tests, but it may be helpful in tracking down a problem in
one's \file{.pydbrc} file.

\item[set linetrace on\code{\Large{|}}off]\label{command:linetrace}

If this is set on the position (file ane linenumber) is shown before
executing a statement. By default this is off. Using the command-line
option \samp{--trace} when invoking \code{pydb} implicitly sets this
on.  For infomration on \samp{--trace}, see \ref{switch:trace}.

You may notice that using this option will slow down your
program. Unless single stepping through a program, normally the
debugger is only called on breakpoints or at the call and return of a
function or method. However when line tracing is turned on, the
debugger is called on execution of every statement. 

That said, execution may still be pretty fast and there are times when
you may want to slow slow down execution \emph{further}\/! For this
see \samp{set linetrace delay} described next.

\item[set linetrace delay \var{time}]

One of the cool things you can do with this debugger if you run it via
a front-end GUI is watch your program as it executes. To do this you
turn on line tracing described previously \samp{set linetrace on} and
that arranges for the location to be printed before each Python
statement is run. Many front-end GUIs like the one in GNU Emacs and
\code{ddd} will read the location and arrange the display to get
updated accordingly. 

There is however one catch---Python runs to fast! So by using this
option you can set a delay after each statement is run in order for
the GNU and your eyes to catch up with Python. You specify a floating
point indicating the number of seconds to wait. For example: 

\begin{verbatim}
set linetrace delay 0.5 # 1/2 a second
\end{verbatim}

In my experience half a second is about right.

\item[set listsize \var{lines}]

This option sets how many lines are shown the list command.

\item[set prompt \var{prompt-string}]\label{command:prompt}

Set debugger's prompt string. By default it is \samp{(Pydb) }. There
is a trailing space in there. For information on how the prompt
changes, see \ref{debugger-prompt}.

\emph{There's currently a bug in the code where trailing blanks
specified are chopped. Furthermore the prompt may change in the future
to add a history number. Unless you have good reason to, it is
generally not advisable to change to prompt.}

\end{description}

\subsubsection{Show ({\tt show})\label{subsubsection:show}}

\begin{description}

\item[show args]

Show argument list to give program being debugged when it is started

\item[show basename]

Show if we are to show short of long filenames

\item[show cmdtrace]

Show if we are to show debugger commands before running

\item[show linetrace]

Show the line tracing status

\item[show linetrace delay]

Show delay after tracing each line

\item[listsize]

Show number of source lines gdb will list by default

\item[show prompt]

Show the current debugger prompt

\item[show version]

Show the debugger version number.

\end{description}

\subsubsection{Info ({\tt info})}

Running this command without parameter will print the list of
available info commands. Below is a description of the individual
commands.

\begin{description}

\item[info args]

See function/method parameters. See \ref{command:info-args}.

\item[info break]

Show the list of breakpoints. 

\item[info globals]

Show global variables. See \ref{command:info-locals}. 

\item[info line]

Current line number in source file

\item[info locals]

Show local variables. See \ref{command:info-locals}. 

\item[info source]

Information about the current Python file.

\end{description}

\subsection{Breakpoints ({\tt break}, {\tt tbreak}, {\tt clear},
  {\tt delete}, {\tt disable}, {\tt
  ignore})\label{subsubsection:brkpts}}

\index{breakpoints}
A ``breakpoint'' makes your program stop whenever a certain point in
the program is reached.  For each breakpoint, you can add conditions
to control in finer detail whether your program stops.  You can set
breakpoints with the `break' command and its variants. You specify the
place where your program should stop by file and line number or
function name.

The debugger assigns a number to each breakpoint when you create it;
these numbers are successive integers starting with one.  In many of
the commands for controlling various features of breakpoints you use
the breakpoint number to say which breakpoint you want to change.
Each breakpoint may be "enabled" or "disabled"; if disabled, it has no
effect on your program until you enable it again.

The debugger allows you to set any number of breakpoints at the same
place in your program.  There is nothing unusual about this because
different breakpoints can have differnt conditions associated with them.

\begin{description}
\item[b(reak) \optional{\optional{\var{filename}:}\var{lineno}\code{\Large{|}}\var{function}\optional{, \var{condition}}}]

With a \var{lineno} argument, set a break there in the current
file.  With a \var{function} argument, set a break at the first
executable statement within that function.
The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that
hasn't been loaded yet).  The file is searched on \code{sys.path}.
Note that each breakpoint is assigned a number to which all the other
breakpoint commands refer.

If a second argument is present, it is an expression which must
evaluate to true before the breakpoint is honored.

Without argument, list all breaks, including for each breakpoint,
the number of times that breakpoint has been hit, the current
ignore count, and the associated condition if any.

\item[tbreak \optional{\optional{\var{filename}:}\var{lineno}\code{\Large{|}}\var{function}\optional{, \var{condition}}}]

Temporary breakpoint, which is removed automatically when it is
first hit.  The arguments are the same as break.

\item[cl(ear) \optional{\var{file:} \optional{\var{linenumber}}}]

Clear breakpoint at specified line or function.  Argument may be line
number, function name, or '*' and an address.  If line number is
specified, all breakpoints in that line are cleared.  If function is
specified, breakpoints at beginning of function are cleared.  If an
address is specified, breakpoints at that address are cleared.

With no argument, clears all breakpoints in the line that the selected
frame is executing in.

See also the \samp{delete} command below which clears breakpoints by
number.

\item[delete \optional{\var{bpnumber} \optional{\var{bpnumber \ldots}}}]

With a space separated list of breakpoint numbers, clear those
breakpoints.  Without argument, clear all breaks (but first
ask confirmation).

\item[disable \optional{\var{bpnumber} \optional{\var{bpnumber \ldots}}}]

Disables the breakpoints given as a space separated list of
breakpoint numbers.  Disabling a breakpoint means it cannot cause
the program to stop execution, but unlike clearing a breakpoint, it
remains in the list of breakpoints and can be (re-)enabled.

\item[enable \optional{\var{bpnumber} \optional{\var{bpnumber \ldots}}}]

Enables the breakpoints specified.

\item[ignore \var{bpnumber} \optional{\var{count}}]

Sets the ignore count for the given breakpoint number.  If
count is omitted, the ignore count is set to 0.  A breakpoint
becomes active when the ignore count is zero.  When non-zero,
the count is decremented each time the breakpoint is reached
and the breakpoint is not disabled and any associated condition
evaluates to true.

\item[condition \var{bpnumber} \optional{\var{condition}}]

Condition is an expression which must evaluate to true before
the breakpoint is honored.  If condition is absent, any existing
condition is removed; i.e., the breakpoint is made unconditional.

\end{description}

\subsection{Resuming Execution ({\tt step}, {\tt next}, {\tt
    finish}, {\tt continue}, {\tt jump})\label{subsubsection:resume}}

``Continuing'' means resuming program execution until your program
completes normally.  In contrast, ``stepping'' means executing just
one statement of your program. Either when continuing or when
stepping, your program may stop even sooner, due to a breakpoint or an
exception.

\begin{description}

\item[s(tep) \optional{\var{count}}]

Execute the current line, stop at the first possible occasion
(either in a function that is called or on the next line in the
current function).

\item[n(ext) \optional{\var{count}}]

Continue execution until the next line in the current function
is reached or it returns.  The difference between \samp{next} and
\samp{step} is that \samp{step} stops inside a called function, while
\samp{next} executes called functions at (nearly) full speed, only
stopping at the next line in the current function.

\item[finish]

Continue execution until the current function returns.

\item[c(ont(inue))]

Continue execution, only stop when a breakpoint is encountered.

\item[j(ump) \var{lineno}]

Set the next line that will be executed.  Only available in the
bottom-most frame.  This lets you jump back and execute code
again, or jump forward to skip code that you don't want to run.

It should be noted that not all jumps are allowed --- for instance it
is not possible to jump into the middle of a \keyword{for} loop or out
of a \keyword{finally} clause.

\end{description}

\subsection{Examining Call Frames ({\tt info args}, {\tt info
    locals}, {\tt info globals}, {\tt up}, {\tt down}, {\tt frame})\label{subsection:frames}}

Each line in the backtrace shows the frame number and the function
name, if it exists and the place in a file where the statement is
located.

Here is an example of a backtrace from a sample Towers of Hanoi
program that is used in regression testing:

\begin{verbatim}
## 0 hanoi() called from file '/tmp/pydb/test/hanoi.py' at line 5
-> 1 hanoi() called from file '/tmp/pydb/test/hanoi.py' at line 6
## 2 in file '/tmp/pydb/test/hanoi.py' at line 29
## 3 in file '<string>' at line 1
## 4 run() called from file '/usr/lib/python2.4/bdb.py' at line 366
\end{verbatim}

The {\tt->} arrow indicates the focus that we are currently
examining. In the above example, I issued an \samp{up} command which
is why the focus is on 1 rather than 0 as it would normally be after a
stop takes place. 

Note that there are two ``hanoi'' frames listed because this is a
hanoi called itself recursively. Note that in frame 2 and 3 we don't
have a function name listed. That's because there is none. Furthermore
in frame 3 we have this funny ``in file '<string>' at line 1''. That's
because there isn't even a file assocated with the command. The
command issued:

\begin{verbatim}
   exec cmd in globals, locals
\end{verbatim}

This statement can be seen in frame 4. This is a bug which I hope to
fix some day with a more informative messages.

Finally, I'll note that frames 2 and 3 really are not part of the
program to be debugged but are part of the internal workings of the
debugger. It's possible to hide this, but in the open spirit of Python
for now it hasn't been.

\begin{description}

\item[info args]\label{command:info-args}

Show the method or function parameters and their values. 

Here is an example of the output for the backtrace of the hanoi
program shown at the beginning of this section:

\begin{verbatim}
(Pydb) info args
n= 3
a= a
b= b
c= c
(Pydb) 
\end{verbatim}

\item[info locals]\label{command:info-locals}

Show all local variables for the given stack frame. This will include
the variables that would be shown by \samp{info args}. For 

\item[where\code{\Large{|}}T\code{\Large{|}}bt]

Print a ballback trace, with the most recent frame at the top.  An
arrow indicates the current frame, which determines the context of
most commands.

An example of a backtrace is given at the beginning of this section.

\item[retval{\Large{|}}rv]

Show the value that will be returned by the current function. This
command is only meaningful just before a return (such as you'd get
using the \samp{finish} command.

\item[d(own) \optional{\var{count}}]

Move the current frame one level down in the stack trace
(to a newer frame). With a count, which can be a positive
or a negative value, move that many positions.

\item[u(p) \optional{\var{count}}]

Move the current frame one level up in the stack trace (to an older
frame). With a count, which can be a positive or a negative value,
move that many positions.

\item[frame \optional{\var{position}}]
Move the current frame to the specified frame number. A negative
number indicates position from the end, so "frame -1" moves to 
the newest frame, and \code{frame 0} moves to the oldest frame.

\end{description}

\subsection{Examining Data ({\tt print}, {\tt pprint}, {\tt examine})\label{subsection:data}}

\begin{description}

\item[p \var{expression}]

Evaluate the \var{expression} in the current context and print its
value.  \note{\samp{print} can also be used, but is not a debugger
command --- this executes the Python \keyword{print} statement.}

\item[pp \var{expression}]

Like the \samp{p} command, except the value of the expression is
pretty-printed using the \module{pprint} module.

\item[examine \var{expression}]

Print the type of the expression and prettyprint its value.  For
functions, methods, classes and modules we print out the documentation
string if any.  For functions we also show the argument list.

The intent here was to be like the examine debugger command in
Perl. However much more work is needed here. Note that \samp{x} is not
a short name for ``expression'' (as it is in Perl's debugger),
although one could easily make it be via an alias. I use the variable
name x too often.

\end{description}

\subsection{Running arbitrary Python commands ({\tt debug}, {\tt !})}

\begin{description}

\item[\optional{!}\var{statement}]

Execute the (one-line) \var{statement} in the context of
the current stack frame.
The exclamation point can be omitted unless the first word
of the statement resembles a debugger command.
To set a global variable, you can prefix the assignment
command with a \samp{global} command on the same line, e.g.:

\begin{verbatim}
(Pydb) global list_options; list_options = ['-l']
(Pydb)
\end{verbatim}

\item[debug \var{statement}]

Enter a recursive debugger that steps through the code argument (which
is an arbitrary expression or statement to be executed in the current
environment). The prompt is changed to indicate nested behavior. See
\ref{debugger-prompt}

\end{description}

\subsection{Listing Program Code ({\tt list}, {\tt disassemble})}

\begin{description}

\item[disassemble \optional{\var{arg}}]

With no argument, disassemble at the current frame location.  With a
numeric argument, disassemble at the frame location at that line
number. With a class, method, function, code or string argument,
disassemble that.

\item[l(ist) \optional{\var{first}\optional{, \var{last}}}]

List source code for the current file.  Without arguments, list
\emph{n} lines around the current line or continue the previous
listing, where \emph{n} is the value set by \samp{set listsize} or
shown by \samp{show listsize}.  The default value is 10.

With one argument, list \emph{n} lines around at that line.  With
two arguments, list the given range; if the second argument is less
than the first, it is interpreted as a count.

\end{description}

\subsection{Miscellaneous Commands}

\begin{description}

\item[h(elp) \optional{\var{command}}]

Without argument, print the list of available commands.  With a
\var{command} as argument, print help about that command.  \samp{help
pydb} displays the full documentation file; if the environment variable
\envvar{PAGER} is defined, the file is piped through that command
instead.  Since the \var{command} argument must be an identifier,
\samp{help exec} must be entered to get help on the \samp{!} command.

\item[alias \optional{\var{name} \optional{command}}]\label{command:aliases}

Creates an alias called \var{name} that executes \var{command}.  The
command must \emph{not} be enclosed in quotes.  Replaceable parameters
can be indicated by \samp{\%1}, \samp{\%2}, and so on, while \samp{\%*} is
replaced by all the parameters.  If no command is given, the current
alias for \var{name} is shown. If no arguments are given, all
aliases are listed.

Aliases may be nested and can contain anything that can be
legally typed at the pydb prompt.  Note that internal pydb commands
\emph{can} be overridden by aliases.  Such a command is
then hidden until the alias is removed.  Aliasing is recursively
applied to the first word of the command line; all other words
in the line are left alone.

As an example, here are two useful aliases (especially when placed
in the \file{.pydbrc} file):

\begin{verbatim}
#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]
#Print instance variables in self
alias ps pi self
\end{verbatim}
                
\item[unalias \var{name}]

Deletes the specified alias.

\item[q(uit)]

Quit from the debugger.
The program being executed is aborted.

\end{description}

\section{The Debugger Module (\module{pydb}) and Class (\class{Pdb}) \label{debugger-module}}

The module \module{pydb} defines an interactive source code
debugger\index{debugging} for Python programs.  It supports setting
(conditional) breakpoints and single stepping at the source line
level, inspection of stack frames, source code listing, and evaluation
of arbitrary Python code in the context of any stack frame.  It also
supports disassembly of code and post-mortem debugging and can be
called under program control.

The debugger is extensible --- it is actually defined as the class
\class{Pdb}\withsubitem{(class in pydb)}{\ttindex{Pdb}}.
This is currently undocumented but easily understood by reading the
source.  The extension interface uses the modules
\module{bdb}\refstmodindex{bdb} (undocumented) and
\refmodule{cmd}\refstmodindex{cmd}.

All of the methods intended for outside use are documented. In fact
the help documentation for commands comes from the document strings of
the corresponding methods.

One class methods that may be useful to subclass are the output
methods \method{errmsg}, \method{msg}, \method{msg_nocr}. In early
regression development I subclassed these so that I could capture
debugger output. (In turned out however that there were far too many
tests that I needed to make and working this way although very precise
would not scale to the vast number of tests I envision.)

All of the debugger commands listed \ref{command:debugger} are methods
of a Pdb object. The method names are the command name prefixed by
\code{do_}. For example the method handling the \samp{step} command is
\code{do_step}, and the command handling the \samp{frame} command is
\code{do_frame}. 

Typical usage to run a program under control of the debugger is:

\begin{verbatim}
>>> import pydb
>>> import mymodule
>>> pydb.run('mymodule.test()')
> <string>(0)?()
(Pydb) continue
> <string>(1)?()
(Pydb) continue
NameError: 'spam'
> <string>(1)?()
(Pydb) 
\end{verbatim}

\file{pydb.py} can also be invoked as
a script to debug other scripts.  For example:

\begin{verbatim}
python -m pydb \var{python-script}
\end{verbatim}

On systems that support it, pydb is a symbolic link to pydb.py which
has been arranged to be executable and contains the proper python
``magic''. So here, instead of the above, one can simply run:

\begin{verbatim}
pydb myscript.py
\end{verbatim}

When invoked as a script, \code{pydb} will automatically enter
post-mortem debugging if the program being debugged exits
abnormally. After post-mortem debugging (or after normal exit of the
program), pydb will restart the program.  Automatic restarting
preserves pydb's state (such as breakpoints) and in most cases is more
useful than quitting the debugger upon program's exit.
\versionadded[Restarting post-mortem behavior added]{2.4}

Typical usage to inspect a crashed program is:

\begin{verbatim}
>>> import pydb
>>> import mymodule
>>> mymodule.test()
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "./mymodule.py", line 4, in test
    test2()
  File "./mymodule.py", line 3, in test2
    print spam
NameError: spam
>>> pydb.pm()
> ./mymodule.py(3)test2()
-> print spam
(Pydb) 
\end{verbatim}

The module defines the following functions; each enters the debugger
in a slightly different way:

\begin{funcdesc}{run}{statement\optional{, globals\optional{, locals}}}
Execute the \var{statement} (given as a string) under debugger
control.  The debugger prompt appears before any code is executed; you
can set breakpoints and type \samp{continue}, or you can step through
the statement using \samp{step} or \samp{next} (all these commands are
explained below).  The optional \var{globals} and \var{locals}
arguments specify the environment in which the code is executed; by
default the dictionary of the module \refmodule[main]{__main__} is
used.  (See the explanation of the \keyword{exec} statement or the
\function{eval()} built-in function.)
\end{funcdesc}

\begin{funcdesc}{runeval}{expression\optional{, globals\optional{, locals}}}
Evaluate the \var{expression} (given as a string) under debugger
control.  When \function{runeval()} returns, it returns the value of the
expression.  Otherwise this function is similar to
\function{run()}.
\end{funcdesc}

\begin{funcdesc}{runcall}{function\optional{, argument, ...}}
Call the \var{function} (a function or method object, not a string)
with the given arguments.  When \function{runcall()} returns, it returns
whatever the function call returned.  The debugger prompt appears as
soon as the function is entered.
\end{funcdesc}

\begin{funcdesc}{set_trace}{}
Enter the debugger at the calling stack frame.  This is useful to
hard-code a breakpoint at a given point in a program, even if the code
is not otherwise being debugged (e.g. when an assertion fails).
\end{funcdesc}

\begin{funcdesc}{post_mortem}{traceback}
Enter post-mortem debugging of the given \var{traceback} object.
\end{funcdesc}

\begin{funcdesc}{pm}{}
Enter post-mortem debugging of the traceback found in
\code{sys.last_traceback}.
\end{funcdesc}

\section{How the Debugger Works \label{debugger-hooks}}

Some changes were made to the interpreter:

\begin{itemize}
\item \code{sys.settrace(\var{func})} sets the global trace function
\item there can also a local trace function (see later)
\end{itemize}

Trace functions have three arguments: \var{frame}, \var{event}, and
\var{arg}. \var{frame} is the current stack frame.  \var{event} is a
string: \code{'call'}, \code{'line'}, \code{'return'}, \code{'exception'},
 \code{'c_call'}, \code{'c_return'}, or \code{'c_exception'}. \var{arg}
 depends on the event type.

The global trace function is invoked (with \var{event} set to
\code{'call'}) whenever a new local scope is entered; it should return
a reference to the local trace function to be used that scope, or
\code{None} if the scope shouldn't be traced.

The local trace function should return a reference to itself (or to
another function for further tracing in that scope), or \code{None} to
turn off tracing in that scope.

Instance methods are accepted (and very useful!) as trace functions.

The events have the following meaning:

\begin{description}

\item[\code{'call'}]
A function is called (or some other code block entered).  The global
trace function is called; \var{arg} is \code{None};
the return value specifies the local trace function.

\item[\code{'line'}]
The interpreter is about to execute a new line of code (sometimes
multiple line events on one line exist).  The local trace function is
called; \var{arg} is \code{None}; the return value specifies the new
local trace function.

\item[\code{'return'}]
A function (or other code block) is about to return.  The local trace
function is called; \var{arg} is the value that will be returned.  The
trace function's return value is ignored.

\item[\code{'exception'}]
An exception has occurred.  The local trace function is called;
\var{arg} is a triple \code{(\var{exception}, \var{value},
\var{traceback})}; the return value specifies the new local trace
function.

\item[\code{'c_call'}]
A C function is about to be called.  This may be an extension function
or a builtin.  \var{arg} is the C function object.

\item[\code{'c_return'}]
A C function has returned. \var{arg} is \code{None}.

\item[\code{'c_exception'}]
A C function has thrown an exception.  \var{arg} is \code{None}.

\end{description}

Note that as an exception is propagated down the chain of callers, an
\code{'exception'} event is generated at each level.

For more information on code and frame objects, refer to the
\ulink{Python Reference
Manual}{http://docs.python.org/ref/ref.html}.
