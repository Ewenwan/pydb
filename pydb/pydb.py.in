#!@PYTHON@ -t
"""$Id: pydb.py.in,v 1.97 2006/07/21 08:17:27 rockyb Exp $
A Python debugger. Contains user-callable routines, e.g.
run, set_trace, runevel.

(See also @PACKAGE_NAME@.doc for documentation.)"""

# This part contains user entry subroutines.

_debugger_name = '@PACKAGE_NAME@'

# The name of the debugger we are currently going by.
_version = '@PACKAGE_VERSION@'

import inspect, os, re, sys, traceback

import pydbcmd, pydbbdb
from pydbdisp import Display, DisplayNode
from fns import *
from gdb import Gdb
from gdb import Restart

__all__ = ["Pdb",     "exception_hook", "help",
           "pm",      "post_mortem", "run",
           "runcall", "runeval",
           "set_trace"]

def init():
    global program
    global _re_linetrace_delay

    program = os.path.basename(sys.argv[0])

class Pdb(Gdb):

    """A debugger class for Python that resembles the gdb (GNU
    debugger) command set. Really we just inherit everything from the
    Gdb class, but we keep the name Pdb to be compatible with the stock
    Python debugger's (pdb's) Pdb class."""

    def __init__(self, completekey='tab', stdin=None, stdout=None):
        Gdb.__init__(self, completekey, stdin, stdout)

#########################################################
# Alternative top-level calls
#########################################################

def run(statement, globals=None, locals=None):

    """Execute the statement (given as a string) under debugger
    control starting with the statement subsequent to the place that
    this call appears in your program.

    The debugger prompt appears before any code is executed;
    you can set breakpoints and type 'continue', or you can step
    through the statement using 'step' or 'next'

    The optional globals and locals arguments specify the environment
    in which the code is executed; by default the dictionary of the
    module __main__ is used."""

    p = Pdb()
    p.running=True
    p.run(statement, globals, locals)

def runeval(expression, globals=None, locals=None):

    """Evaluate the expression (given as a string) under debugger
    control starting with the statement subsequent to the place that
    this appears in your program.

    When runeval() returns, it returns the value of the expression.
    Otherwise this function is similar to run()."""

    p = Pdb()
    p.running=True
    return p.runeval(expression, globals, locals)

def runcall(*args, **kwds):

    """ Call the function (a function or method object, not a string)
    with the given arguments starting with the statement subsequent to
    the place that this appears in your program.

    When runcall() returns, it returns whatever the function call
    returned.  The debugger prompt appears as soon as the function is
    entered."""

    p = Pdb()
    p.running=True
    return p.runcall(*args, **kwds)

def set_trace(opts=None, add_exception_hook=True):
    """Enter the debugger at the calling stack frame.  This is useful to
    hard-code a breakpoint at a given point in a program, even if the code
    is not otherwise being debugged (e.g., when an assertion fails).
    Leaving this the debugger terminates the program.

    Opts is an optional dictionary of debugger variables you want set;
    the key is the variable name and the value is the value to give
    the variable in the pydb instance.

    If add_exception is True (the default), we will install an exception hook
    to call the post-mortem debugger on an unhandled exception. 
    """
    global _pydb_trace
    try:
        if not isinstance(_pydb_trace, Pdb):
            print "Your program should not use _pydb_trace"
            return
    except NameError:
        _pydb_trace = Pdb()
        _pydb_trace.reset()
        _pydb_trace._program_sys_argv = list(sys.argv)
        _pydb_trace._sys_argv = list(_pydb_trace._program_sys_argv)
        _pydb_trace._sys_argv[:0] = [_debugger_name]
        _pydb_trace.main_dirname = os.path.dirname(sys.argv[0])
    except:
        print "Unknown error"
        return
    # We don't support "run" so we'll make "run" and "R" be "restart"
    _pydb_trace.do_R = _pydb_trace.do_run = _pydb_trace.do_restart
    _pydb_trace.curframe=inspect.currentframe()
    _pydb_trace.running = True

    # We put processing opts after the above traceback loop so we will
    # smash p.mainpyfile if it is given as an option.
    if opts is not None:
        for item in opts.items(): exec "p.%s=%s" % item

    if add_exception_hook:
        sys.excepthook = exception_hook

    # There can be no other commands after the following one:
    if sys.version_info[0] == 2 and sys.version_info[1] >= 4:
        _pydb_trace.set_trace(_pydb_trace.curframe)
    else:
        # older versions
        _pydb_trace.set_trace()  

# Post-Mortem interface

def post_mortem(t=None, opts=None, cmdfile=None, frameno=1):
    """Enter debugger read loop after your program has crashed.

    If no traceback parameter, t, is supplied, the last traceback and
    if that doesn't exist either we'll assume that sys.exec_info()
    contains what we want and frameno is the index location of where
    we want to start.

    cmdfile is an optional debugger command file you want to run
    "source" on.
    
    Opts is an optional dictionary of debugger variables you want set;
    the key is the variable name and the value is the value to give
    the variable in the @PACKAGE_NAME@ instance.
    """

    p = Pdb()
    p.reset()
    p.running = False
    re_bogus_file = re.compile("^<.+>$")

    if t is None: 
        # frameno+1 because we are about to add one more level of call
        # in get_last_tb_or_frame_tb
        t = get_last_tb_or_frame_tb(frameno+1)

    # t has least-recent traceback entry first. We want the most-recent
    # entry. Also we'll pick out a mainpyfile name if it hasn't previously
    # been set.
    while t.tb_next is not None:
        filename = t.tb_frame.f_code.co_filename
        if 0 == len(p.mainpyfile) and not re_bogus_file.match(filename):
            p.mainpyfile = filename
        t = t.tb_next
    p.curframe = t.tb_frame

    # We put processing opts after the above traceback loop so we will
    # smash p.mainpyfile if it is given as an option.
    if opts is not None:
        for item in opts.items(): exec "p.%s=%s" % item

    if 0 == len(p._program_sys_argv):
        # Fake program (run command) args since we weren't called with any
        p._program_sys_argv = list(sys.argv[1:])
        p._program_sys_argv[:0] = [p.mainpyfile]

    if 0 == len(p._sys_argv):
        # Fake script invocation (restart) args since we don don't have any
        p._sys_argv = list(p._program_sys_argv)
        p._sys_argv[:0] = [_debugger_name]

    if cmdfile is not None:
        p.do_source(cmdfile)
        
    try:

        # FIXME: This can be called from except hook in which case we
        # need this. Dunno why though.
        try: 
            _pydb_trace.set_trace(t.tb_frame)
        except:
            pass

        p.interaction(t.tb_frame, t)
    except Restart:
        while True:
            sys.argv = list(p._program_sys_argv)
            p.msg("Restarting %s with arguments:\n\t%s"
                  % (p.filename(p.mainpyfile),
                     " ".join(p._program_sys_argv[1:])))
            try:
                p._runscript(p.mainpyfile)
                if p._user_requested_quit:
                    break
                if p.noninteractive: break
            except Restart:
                pass

def pm(opts=None, cmdfile=None, frameno=1):

    """Set up post-mortem debugging using the last traceback.  But if
    there is no traceback, we'll assume that sys.exec_info() contains
    what we want and frameno is the index location of where we want
    to start.
    
    Opts is a dictionary of debugger variables you want set;
    the key is the variable name and the value is the value to give
    the variable in the @PACKAGE_NAME@ instance."""

    # frameno+1 because we are about to add one more level of call
    # in get_last_tb_or_frame_tb
    tb = get_last_tb_or_frame_tb(frameno+1)
    post_mortem(tb, opts, cmdfile)

def exception_hook(type, value, tb, opts=None, cmdfile=None):
    """An exception hook to call @PACKAGE_NAME@'s post-mortem debugger.

    cmdfile is an optional debugger command file you want to run
    "source" on.
    
    Opts is an optional dictionary of debugger variables you want set;
    the key is the variable name and the value is the value to give
    the variable in the @PACKAGE_NAME@ instance.

    To use add this to your Python program
       import sys
       sys.excepthook = @PACKAGE_NAME@.exception_hook
    """
    traceback.print_exception(type, value, tb)
    post_mortem(tb, opts, cmdfile, 0)


# print help
def help():
    doc_file='%s.doc' % _debugger_name
    for dirname in sys.path:
        fullname = os.path.join(dirname, _debugger_name, doc_file)
        if os.path.exists(fullname):
            sts = os.system('${PAGER-more} '+fullname)
            if sts: self.errmsg('Pager exit status: %s' % str(sts))
            break
    else:
        print ("Sorry, can't find the help file '%s' along the "
                  + "Python search path") % doc_file

#########################################################
# Main program
#########################################################

def main():
    """Routine which gets run if we were invoked directly"""

    pydb = Pdb()
    opts = process_options(pydb, _debugger_name, program, '@PACKAGE_VERSION@')

    # process_options has munged sys.argv to remove any options that
    # options that belong to this debugger. The original options to
    # invoke the debugger and script are in global sys_argv

    if len(sys.argv) == 0:
        # No program given to debug. Set to go into a command loop
        # anyway
        mainpyfile = None

    else:
        # Save the DEBUGGED programs arguments. This is in case
        # the debugged script munges these, we have a good copy to use
        # for restart
        pydb._program_sys_argv = list(sys.argv)

        mainpyfile = pydb._program_sys_argv[0] # Get script filename. 
        if not os.path.exists(mainpyfile):
            print 'Error:', mainpyfile, 'does not exist'
            sys.exit(1)

        # Replace @PACKAGE_NAME@'s dir with script's dir in front of
        # module search path.
        sys.path[0] = pydb.main_dirname = os.path.dirname(mainpyfile)

    while True:

        # Run the debugged script over and over again until we get it
        # right.

        try:
            if mainpyfile:
                pydb._runscript(mainpyfile)
            else:
                pydb._wait_for_mainpyfile = True
                pydb.interaction(None, None)

            if pydb._user_requested_quit: break
            if pydb.noninteractive: break
            pydb.msg("The program finished and will be restarted")
        except Restart:
            if pydb._program_sys_argv:
                sys.argv = list(pydb._program_sys_argv)
                pydb.msg("Restarting %s with arguments:\n\t%s"
                         % (pydb.filename(mainpyfile),
                            " ".join(pydb._program_sys_argv[1:])))
            else: break
        except SystemExit:
            # In most cases SystemExit does not warrant a post-mortem session.
            pydb.msg("The program exited via sys.exit(). Exit status: %s" %
                     str(sys.exc_info()[1]))
            pydb.running = False;
            if pydb.noninteractive: break
        except:
            traceback.print_exc()
            if pydb.noninteractive:
                pydb.errmsg("Uncaught exception.")
                break
            pydb.errmsg("Uncaught exception. Entering post mortem debugging")
            pydb.errmsg( "Running 'c' or 'step' will restart the program")
            pydb.running = False;
            t = sys.exc_info()[2]
            while t.tb_next is not None:
                t = t.tb_next
            try:
                pydb.interaction(t.tb_frame,t)
            except Restart:
                sys.argv = list(pydb._program_sys_argv)
                pydb.msg("Restarting %s with arguments:\n\t%s"
                         % (pydb.filename(mainpyfile),
                            " ".join(pydb._program_sys_argv[1:])))
            else:
                pydb.msg("Post mortem debugger finished.")
                pydb.msg(mainpyfile + " will be restarted")
        pydb.step_ignore = 0

init()

# When invoked as main program, invoke the debugger on a script
if __name__=='__main__':
    main()

#
# Local variables:
#  mode: Python
# End:
