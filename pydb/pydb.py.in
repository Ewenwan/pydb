#!@PYTHON@ -t
"""$Id: pydb.py.in,v 1.84 2006/05/30 00:33:12 rockyb Exp $
A Python debugger. (See also @PACKAGE_NAME@.doc for documentation.)"""

# This part contains user entry subroutines.

_debugger_name = '@PACKAGE_NAME@'

# The name of the debugger we are currently going by.
_version = '@PACKAGE_VERSION@'

import inspect, os, re, sys, traceback

import pydbcmd, pydbbdb
from pydbdisp import Display, DisplayNode
from fns import *
from gdb import Gdb
from gdb import Restart

__all__ = ["Pdb",     "help",
           "pm",      "post_mortem", "run",
           "runcall", "runeval",
           "set_trace"]

def init():
    global program
    global _re_linetrace_delay

    program = os.path.basename(sys.argv[0])

class Pdb(Gdb):
    def __init__(self, completekey='tab', stdin=None, stdout=None):
        Gdb.__init__(self, completekey, stdin, stdout)

#########################################################
# Alternative top-level calls
#########################################################

def run(statement, globals=None, locals=None):
    """Execute the statement (given as a string) under debugger
    control. The debugger prompt appears before any code is executed;
    you can set breakpoints and type 'continue', or you can step
    through the statement using 'step' or 'next'

    The optional globals and locals arguments specify the environment
    in which the code is executed; by default the dictionary of the
    module __main__ is used."""
    
    Pdb().run(statement, globals, locals)

def runeval(expression, globals=None, locals=None):
    """Evaluate the expression (given as a string) under debugger
    control.  When runeval() returns, it returns the value of the
    expression.  Otherwise this function is similar to run()."""

    return Pdb().runeval(expression, globals, locals)

def runcall(*args, **kwds):
    """ Call the function (a function or method object, not a string)
    with the given arguments.  When runcall() returns, it returns
    whatever the function call returned.  The debugger prompt appears
    as soon as the function is entered."""

    return Pdb().runcall(*args, **kwds)

def set_trace(cmdfile=None):
    """Enter the debugger at the calling stack frame.  This is useful to
    hard-code a breakpoint at a given point in a program, even if the code
    is not otherwise being debugged (e.g., when an assertion fails).
    Leaving this the debugger terminates the program.
    """
    global _pydb_trace
    try:
        if not isinstance(_pydb_trace, Pdb):
            print "Your program should not use _pydb_trace"
            return
    except NameError:
        _pydb_trace = Pdb()
        _pydb_trace.reset()
        _pydb_trace._program_sys_argv = list(sys.argv)
        _pydb_trace._sys_argv = list(_pydb_trace._program_sys_argv)
        _pydb_trace._sys_argv[:0] = [_debugger_name]
    except:
        print "Unknown error"
        return
    # We don't support "run" so we'll make "run" and "R" be "restart"
    _pydb_trace.do_R = _pydb_trace.do_run = _pydb_trace.do_restart
    _pydb_trace.curframe=inspect.currentframe()
    _pydb_trace.running = True

    if cmdfile is not None: _pydb_trace.do_source(cmdfile)

    # There can be no other commands after the following one:
    _pydb_trace.set_trace(_pydb_trace.curframe)

# Post-Mortem interface

def post_mortem(t, opts=None, cmdfile=None):
    """Enter debugger read loop after your program has crashed.
    Opts is a dictionary of debugger variables you want set;
    the key is the variable name and the value is the value to give
    the variable in the @PACKAGE_NAME@ instance."""
    p = Pdb()
    p.reset()
    p.running = False
    re_bogus_file = re.compile("^<.+>$")

    # t has least-recent traceback entry first. We want the most-recent
    # entry. Also we'll pick out a mainpyfile name if it hasn't previously
    # been set.
    while t.tb_next is not None:
        filename = t.tb_frame.f_code.co_filename
        if 0 == len(p.mainpyfile) and not re_bogus_file.match(filename):
            p.mainpyfile = filename
        t = t.tb_next
    p.curframe = t.tb_frame

    # We put processing opts after the above traceback loop so we will
    # smash p.mainpyfile if it is given as an option.
    if opts is not None:
        for item in opts.items(): exec "p.%s=%s" % item

    if 0 == len(p._program_sys_argv):
        # Fake program (run command) args since we weren't called with any
        p._program_sys_argv = list(sys.argv[1:])
        p._program_sys_argv[:0] = [p.mainpyfile]

    if 0 == len(p._sys_argv):
        # Fake script invocation (restart) args since we don don't have any
        p._sys_argv = list(p._program_sys_argv)
        p._sys_argv[:0] = [_debugger_name]

    if cmdfile is not None:
        p.do_source(cmdfile)
        
    try:
        p.interaction(t.tb_frame, t)
    except Restart:
        while True:
            sys.argv = list(p._program_sys_argv)
            p.msg("Restarting %s with arguments:\n\t%s"
                  % (p.filename(p.mainpyfile),
                     " ".join(p._program_sys_argv[1:])))
            try:
                p._runscript(p.mainpyfile)
                if p._user_requested_quit:
                    break
                if p.noninteractive: break
            except Restart:
                pass

def pm(opts=None, cmdfile=None):
    """Set up post-mortem debugging using the last traceback.
    Opts is a dictionary of debugger variables you want set;
    the key is the variable name and the value is the value to give
    the variable in the @PACKAGE_NAME@ instance."""
    try:
        if not inspect.istraceback(sys.last_traceback):
            print "*** sys.last_traceback is not a traceback?!"
            return
    except AttributeError:
        print "*** Can't find exception to run a post-mortem over."
        return
    post_mortem(sys.last_traceback, opts, cmdfile)

# print help
def help():
    doc_file='%s.doc' % _debugger_name
    for dirname in sys.path:
        fullname = os.path.join(dirname, _debugger_name, doc_file)
        if os.path.exists(fullname):
            sts = os.system('${PAGER-more} '+fullname)
            if sts: self.errmsg('Pager exit status: %s' % str(sts))
            break
    else:
        print ("Sorry, can't find the help file '%s' along the "
                  + "Python search path") % doc_file

#########################################################
# Main program
#########################################################

def main():
    """Routine which gets run if we were invoked directly"""

    pydb = Pdb()
    opts = process_options(pydb, _debugger_name, program)

    # process_options has munged sys.argv to remove any options that
    # options that belong to this debugger. The original options to
    # invoke the debugger and script are in global sys_argv

    if len(sys.argv) == 0:
        print 'Error: you need to give a script name to debug'
        sys.exit(1)

    # Save the DEBUGGED programs arguments. This is in case
    # the debugged script munges these, we have a good copy to use
    # for restart
    pydb._program_sys_argv = list(sys.argv)

    mainpyfile = pydb._program_sys_argv[0] # Get script filename. 
    if not os.path.exists(mainpyfile):
        print 'Error:', mainpyfile, 'does not exist'
        sys.exit(1)

    # Replace @PACKAGE_NAME@'s dir with script's dir in front of
    # module search path.
    sys.path[0] = os.path.dirname(mainpyfile)

    while True:

        # Run the debugged script over and over again until we get it
        # right.

        try:
            pydb._runscript(mainpyfile)
            if pydb._user_requested_quit: break
            if pydb.noninteractive: break
            pydb.msg("The program finished and will be restarted")
        except Restart:
            sys.argv = list(pydb._program_sys_argv)
            pydb.msg("Restarting %s with arguments:\n\t%s"
                     % (pydb.filename(mainpyfile),
                        " ".join(pydb._program_sys_argv[1:])))
        except SystemExit:
            # In most cases SystemExit does not warrant a post-mortem session.
            pydb.msg("The program exited via sys.exit(). Exit status: %s" %
                     str(sys.exc_info()[1]))
            pydb.running = False;
            if pydb.noninteractive: break
        except:
            traceback.print_exc()
            if pydb.noninteractive:
                pydb.errmsg("Uncaught exception.")
                break
            pydb.errmsg("Uncaught exception. Entering post mortem debugging")
            pydb.errmsg( "Running 'c' or 'step' will restart the program")
            pydb.running = False;
            t = sys.exc_info()[2]
            while t.tb_next is not None:
                t = t.tb_next
            try:
                pydb.interaction(t.tb_frame,t)
            except Restart:
                sys.argv = list(pydb._program_sys_argv)
                pydb.msg("Restarting %s with arguments:\n\t%s"
                         % (pydb.filename(mainpyfile),
                            " ".join(pydb._program_sys_argv[1:])))
            else:
                pydb.msg("Post mortem debugger finished.")
                pydb.msg(mainpyfile + " will be restarted")
        pydb.step_ignore = 0

init()

# When invoked as main program, invoke the debugger on a script
if __name__=='__main__':
    main()

#
# Local variables:
#  mode: Python
# End:
