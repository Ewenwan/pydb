#!@PYTHON@
"""$Id: pydb.py.in,v 1.50 2006/02/23 02:06:51 rockyb Exp $
A Python debugger. (See also @PACKAGE_NAME@.doc for documentation.)"""

_debugger_name = '@PACKAGE_NAME@'

# The name of the debugger we are currently going by.
_version = '@PACKAGE_VERSION@'

import bdb, cmd, dis, inspect, linecache, os, pprint
import re, sys, time, traceback, types

from pydbdisp import Display, DisplayNode
from pydbfns import *
from repr import Repr

class Restart(Exception):
    """Causes a debugger to be restarted for the debugged Python program."""
    pass

__all__ = ["run", "pm", "Pdb", "runeval", "runctx", "runcall", "set_trace",
           "post_mortem", "help"]

def init():
    global program, _repr, _saferepr, step_ignore_count
    global _re_linetrace_delay

    program = os.path.basename(sys.argv[0])

    # Create a custom safe Repr instance and increase its maxstring.
    # The default of 30 truncates error messages too easily.
    _repr = Repr()
    _repr.maxstring = 200
    _saferepr = _repr.repr

    _re_linetrace_delay = re.compile(r'\s*linetrace\s*')

    # step_ignore_count should be an instance variable inside the Pdb
    # object but for reasons I don't understand yet, changing the value
    # inside do_next or do_step doesn't seem to persist when it is looked
    # at in user_line()
    
    # A 0 value means stop on this occurance. A positive value means to
    # skip that many more step/next's.
    step_ignore_count = 0

# Interaction prompt line will separate file and call info from code
# text using value of line_prefix string.  A newline and arrow may
# be to your liking.  You can set it once pydb is imported using the
# command "pydb.line_prefix = '\n% '".
# line_prefix = ': '    # Use this to get the old situation back
line_prefix = '\n-> '   # Probably a better default

class Pdb(bdb.Bdb, cmd.Cmd):

    def __init__(self):
        bdb.Bdb.__init__(self)
        cmd.Cmd.__init__(self)

        self._wait_for_mainpyfile = False
        self.aliases         = {}
        self.basename        = False
        self.cmdtrace        = False
        self.currentbp       = None   # for "info program"
        self.display         = Display()
        self.gdb_dialect     = True   # Controls how stack is shown
        self.linetrace       = False
        self.linetrace_delay = 0
        self.listsize        = 10
        self.mainpyfile      = ''
        self.maxargstrsize   = 30     # max length to show of parameter string 
        self.moduletodebug   = ""
        self.nohelp          = 'Undefined command: \"%s\". Try \"help\".'
        self.noninteractive  = False
        self.originalpath    = sys.path[:]
        self.prompt          = '(Pydb) '
        self.rcLines         = []
        self.running         = False
        self.stop_reason     = None   # Why are we in the debugger?

        # Try to load readline if it exists
        try:
            import readline
        except ImportError:
            pass

    def __adjust_frame(self, pos, absolute_pos):
        """Adjust stack frame by pos positions. If absolute_pos then
        pos is an absolute number. Otherwise it is a relative number.

        If self.gdb_dialect is True, the 0 position is the newest entry and
        doesn't match Python's indexing. Otherwise it does.

        A negative number indexes from the other end.
        """

        # Below we remove any negativity. At the end, pos will be
        # the new value of self.curindex.
        if absolute_pos:
            if self.gdb_dialect:
                if pos >= 0:
                    pos = len(self.stack)-pos-1
                else:
                    pos -= len(self.stack)
            elif pos < 0:
                pos = len(self.stack)+pos
        else:
            pos += self.curindex

        if pos < 0:
            self.errmsg("Adjusting would be put us beyond the oldest frame")
            return
        elif pos >= len(self.stack):
            self.errmsg("Adjusting would be put us beyond the newest frame")
            return

        self.curindex = pos
        self.curframe = self.stack[self.curindex][0]
        self.print_location()
        self.lineno = None

    def __get_brkpt_lineno(self, arg):
        """__get_brkpt_lineno(self,arg)->(fn, file, lineno)
        See if arg is a line number or a function name.
        Return what we've found. None can be returned as a value
        in the triple.
        """

        funcname, filename = (None, None)
        try:
            # First try as an integer
            lineno = int(arg)
        except ValueError:
            try:
                func = eval(arg, self.curframe.f_globals,
                            self.curframe.f_locals)
            except:
                func = arg
            try:
                if hasattr(func, 'im_func'):
                    func = func.im_func
                code = func.func_code
                #use co_name to identify the bkpt (function names
                #could be aliased, but co_name is invariant)
                funcname = code.co_name
                lineno = code.co_firstlineno
                filename = code.co_filename
            except:
                # last thing to try
                (ok, filename, ln) = self.lineinfo(arg)
                if not ok:
                    self.errmsg(('The specified object %s is not'
                                 +' a function or was not found '
                                 +' along sys.path.') % str(repr(arg)))
                    return (None, None, None)
                funcname = ok # ok contains a function name
                lineno = int(ln)
        return (funcname, filename, lineno)

    def __get_int(self, arg, default=1, cmdname=None):
        """If arg is an int, use that otherwise take default."""
        if arg:
            try: 
                default = int(arg)
            except ValueError, msg:
                if cmdname:
                    self.errmsg('%s command: Expecting an integer, got: %s' %
                                (cmdname, str(arg)))
                else:
                    self.errmsg('Expecting an integer, got: %s' % str(arg))
                raise ValueError
        return default

    def __get_onoff(self, arg, default=None):
        """Return True if arg is 'on' or 1 and False arg is an 'off' or 0
        Any other value is an error"""
        if not arg:
            if default is None:
                self.errmsg("Expecting 'on', 1, 'off', or 0. Got nothing.")
                raise ValueError
            return default
        if arg == '1' or arg == 'on': return True
        if arg == '0' or arg =='off': return False
        
        self.errmsg("Expecting 'on', 1, 'off', or 0. Got: %s." % str(arg))
        raise ValueError

    def __get_pos_int(self, arg, min=0, default = 1, cmdname=None):
        """If no argument use the default If arg is a positive int at
        least min, use that otherwise report an error."""
        if arg:
            try: 
                default = int(arg)
                if default < min:
                    if cmdname:
                        self.errmsg(('%s command: Expecting a positive ' +
                                     'integer at least %d, got: %d') 
                                    % (cmdname, min, default))
                    else: 
                        self.errmsg(('Expecting a positive ' +
                                     'integer at least %d, got: %d') 
                                    % (cmdname, min, default))
                    # Really should use something custom? 
                    raise ZeroDivisionError
                    
            except ValueError, msg:
                if cmdname:
                    self.errmsg(('%s command: Expecting a positive integer, '
                                 + "got: %s") % (cmdname, str(arg)))
                else:
                    self.errmsg(('Expecting a positive integer, '
                                 + "got: %s") % (cmdname, str(arg)))
                raise ValueError
            except ZeroDivisionError:
                # Turn this into a ValueError
                raise ValueError
        return default

    def __getval(self, arg):
        try:
            return eval(arg, self.curframe.f_globals,
                        self.curframe.f_locals)
        except:
            t, v = sys.exc_info()[:2]
            if isinstance(t, str):
                exc_type_name = t
            else: exc_type_name = t.__name__
            self.errmsg(str("%s: %s" % (exc_type_name, arg)))
            raise

    def __help_info(self, cmd, label=False):
        """Show help for a single 'info' subcommand"""
        if label:
            self.msg_nocr("info %s --" % cmd)
        if cmd == 'args':
            self.msg("Argument variables of current stack frame")
        elif cmd == 'display':
            self.msg("Expressions to display when program stops, " +
                     "with code numbers.")
        elif cmd == 'break':
            self.msg("Status of user-settable breakpoints")
        elif cmd == 'globals':
            self.msg("Global variables of current stack frame")
        elif cmd == 'line':
            self.msg("Current line number in source file")
        elif cmd == 'locals':
            self.msg("Local variables of current stack frame")
        elif cmd == 'program':
            self.msg("Execution status of the program")
        elif cmd == 'source':
            self.msg("Information about the current Python file")
        else:
            self.errmsg("Unknown 'help info' subcommand %s." % cmd)

    def __help_set(self, cmd, label=False):
        """Show help for a single set subcommand"""
        if label:
            self.msg_nocr("set %s --" % cmd)
        if cmd == 'args':
            self.msg("Set argument list to give program being debugged when it is started")
        elif cmd == 'basename':
            self.msg("Set short filenames (the basename) in debug output")
        elif cmd == 'cmdtrace':
            self.msg("Set to show lines read from the " +
                     "debugger command file")
        elif cmd == 'interactive':
            self.msg("Set whether we are interactive")
        elif cmd == 'linetrace':
            self.msg("Set line execution tracing and delay on tracing")
        elif cmd == 'listsize':
            self.msg("Set number of source lines the debugger will list "
                     + "by default")
        elif cmd == 'prompt':
            self.msg("Set debugger's prompt")
        else:
            self.errmsg("Unknown 'help set' subcommand %s." % cmd)

    def __help_show(self, cmd, label=False):
        """Show help for a single set subcommand"""
        if label:
            self.msg_nocr("show %s --" % cmd)
        if cmd == 'args':
            self.msg("Show argument list to give debugged program on start")
        elif cmd == 'basename':
            self.msg("Show if we are to show short of long filenames")
        elif cmd == 'cmdtrace':
            self.msg("Show if we are to show debugger commands " +
                     "before running")
        elif cmd == 'interactive':
            self.msg("Show whether we are interactive")
        elif cmd == 'linetrace':
            self.msg("Show the line tracing status. Can also add 'delay'")
        elif cmd == 'listsize':
            self.msg("Show number of source lines the debugger will list "
                     + "by default")
        elif cmd == 'prompt':
            self.msg("Show debugger's prompt")
        elif cmd == 'version':
            self.msg("Show what version of this is")
        else:
            self.errmsg("Unknown 'help set' subcommand %s." % cmd)

    # Note: format of help is compatible with ddd.
    def __help_subcommand(self, cmd, doc, subcmds, help_prog, args):
        """Generic command for showing things about the program being debugged."""
        if len(args) == 0:
            self.msg(doc)
            self.msg("""
List of %s subcommands:
""" % (cmd))
            for subcmd in subcmds:
                help_prog(subcmd, True)
            return
        if len(args) == 1:
            subcmd = args[0]
            if subcmd in subcmds:
                help_prog(subcmd)
            else:
                self.errmsg("Unknown 'help %s' subcommand %s" % (cmd, subcmd))
        else:
            self.errmsg("Can only handle 'help %s', or 'help %s *subcmd*'"
                        % (cmd, cmd))

    def __info_args(self, arg):
        """Print the arguments of the current function."""
        f = self.curframe
        co = f.f_code
        dict = f.f_locals
        n = co.co_argcount
        if co.co_flags & inspect.CO_VARARGS: n += 1
        if co.co_flags & inspect.CO_VARKEYWORDS: n += 1
        for i in range(n):
            name = co.co_varnames[i]
            self.msg_nocr("%s=" %  name)
            if name in dict: self.msg(dict[name])
            else: self.msg("*** undefined ***")

    def __print_location_if_linetrace(self, frame):
        if self.linetrace:
            self.setup(frame)
            self.print_location()
            if self.linetrace_delay:
                time.sleep(self.linetrace_delay)

    def bpprint(self, bp):
        if bp.temporary:
            disp = 'del  '
        else:
            disp = 'keep '
        if bp.enabled:
            disp = disp + 'y  '
        else:
            disp = disp + 'n  '
        self.msg('%-4dbreakpoint    %s at %s:%d' %
                 (bp.number, disp, self.filename(bp.file), bp.line))
        if bp.cond:
            self.msg('\tstop only if %s' % (bp.cond))
        if bp.ignore:
            self.msg('\tignore next %d hits' % (bp.ignore))
        if (bp.hits):
            if (bp.hits > 1): ss = 's'
            else: ss = ''
            self.msg('\tbreakpoint already hit %d time%s' %
                     (bp.hits, ss))

    def canonic_filename(self, frame):
        return self.canonic(frame.f_code.co_filename)

    def checkline(self, filename, lineno):
        """Check whether specified line seems to be executable.

        Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank
        line or EOF). Warning: testing is not comprehensive.
        """
        line = linecache.getline(filename, lineno)
        if not line:
            self.errmsg('End of file')
            return 0
        line = line.strip()
        # Don't allow setting breakpoint at a blank line
        if (not line or (line[0] == '#') or
             (line[:3] == '"""') or line[:3] == "'''"):
            self.errmsg('Blank or comment')
            return 0
        return lineno

    def clear_break(self, filename, lineno):
        filename = self.canonic(filename)
        if not filename in self.breaks:
            self.errmsg('No breakpoint at %s:%d.'
                        % (self.filename(filename), lineno))
            return ()
        if lineno not in self.breaks[filename]:
            self.errmsg('No breakpoint at %s:%d.'
                        % (self.filename(filename), lineno))
            return()
        # If there's only one bp in the list for that file,line
        # pair, then remove the breaks entry
        brkpts = []
        for bp in bdb.Breakpoint.bplist[filename, lineno][:]:
            brkpts.append(bp.number)
            bp.deleteMe()
        if not bdb.Breakpoint.bplist.has_key((filename, lineno)):
            self.breaks[filename].remove(lineno)
        if not self.breaks[filename]:
            del self.breaks[filename]
        return brkpts

    def default(self, line):
        if line[:1] == '#': return
        if line[:1] == '!': line = line[1:]
        locals = self.curframe.f_locals
        globals = self.curframe.f_globals
        try:
            code = compile(line + '\n', '<stdin>', 'single')
            exec code in globals, locals
        except:
            t, v = sys.exc_info()[:2]
            if type(t) == types.StringType:
                exc_type_name = t
            else: exc_type_name = t.__name__
            self.errmsg('%s: %s' % (str(exc_type_name), str(v)))

    # To be overridden in derived debuggers
    def defaultFile(self):
        """Produce a reasonable default."""
        filename = self.curframe.f_code.co_filename
        # Consider using is_exec_stmt(). I just don't understand
        # the conditions under which the below test is true.
        if filename == '<string>' and self.mainpyfile:
            filename = self.mainpyfile
        return filename

    def display_enable(self, arg, flag):
        # arg is list of display points
        for i in arg:
            try:
                i = int(i)
                self.display.enable(i, flag)
            except ValueError:
                self.msg('index %r is not a number' % i)
                continue

    def lineinfo(self, identifier):
        failed = (None, None, None)
        # Input is identifier, may be in single quotes
        idstring = identifier.split("'")
        if len(idstring) == 1:
            # not in single quotes
            id = idstring[0].strip()
        elif len(idstring) == 3:
            # quoted
            id = idstring[1].strip()
        else:
            return failed
        if id == '': return failed
        parts = id.split('.')
        # Protection for derived debuggers
        if parts[0] == 'self':
            del parts[0]
            if len(parts) == 0:
                return failed
        # Best first guess at file to look at
        fname = self.defaultFile()
        if len(parts) == 1:
            item = parts[0]
        else:
            # More than one part.
            # First is module, second is method/class
            f = self.lookupmodule(parts[0])
            if f:
                fname = f
            item = parts[1]
        answer = find_function(item, fname)
        return answer or failed

    def errmsg(self, msg):
        """Common routine for reporting debugger error messages.
           Derived classed may want to override this to capture output.
           """
        print "*** %s" % msg

    # Can be executed earlier than 'setup' if desired
    def execRcLines(self):

        """Some commands were batched in self.rcLines.  Run as many of
        them as we can now.
        
        To be compatible with onecmd will return 1 if we are to
        continue execution and None if not -- continue debugger
        commmand loop reading.  The remaining lines will still be in
        self.rcLines.  """

        if self.rcLines:
            # Make local copy because of recursion
            rcLines = self.rcLines
            # executed only once
            for line in rcLines:
                self.rcLines = self.rcLines[1:]
                line = line[:-1]
                if self.cmdtrace: self.msg("+ %s" % line)
                if len(line) > 0 and line[0] != '#':
                    # Some commands like step, continue,
                    # return return 1 to indicate execution
                    # should be continued. The return code
                    # value is kind of sucky but at present
                    # it's too much work to fix all of the
                    # places needed. So live with it.
                    if self.onecmd(line) == 1:
                        return 1

    def filename(self, filename=None):
        if filename is None:
            filename = self.file
        """Return filename or the basename of that depending on the
        self.basename setting"""
        if self.basename:
            return(os.path.basename(filename))
        return filename

    def forget(self):
        self.lineno = None
        self.stack = []
        self.curindex = 0
        self.curframe = None

    def format_stack_entry(self, frame_lineno):
        """Format and return a stack entry gdb-style. """
        import linecache, repr
        frame, lineno = frame_lineno
        filename = self.filename(self.canonic_filename(frame))

        s = ''
        if frame.f_code.co_name:
            s = frame.f_code.co_name
        else:
            s = "<lambda>"

        args, varargs, varkw, locals = inspect.getargvalues(frame)
        parms=inspect.formatargvalues(args, varargs, varkw, locals)
        if len(parms) >= self.maxargstrsize:
            parms = "%s...)" % parms[0:self.maxargstrsize]
        s += parms

        # ddd can't handle wrapped stack entries.
        # if len(s) >= 35:
        #    s += "\n    "

        if '__return__' in frame.f_locals:
            rv = frame.f_locals['__return__']
            s += '->'
            s += repr.repr(rv)

        add_quotes_around_file = True
        if s == '?()':
            if is_exec_stmt(frame):
                s = 'in exec'
                exec_str = get_exec_string(frame.f_back)
                if exec_str != None:
                    filename = exec_str
                    add_quotes_around_file = False
            else:
                s = 'in file'
        else:
            s += ' called from file'

        if add_quotes_around_file: filename = "'%s'" % filename
        s += " %s at line %r" % (filename, lineno)
        return s

    def interaction(self, frame, traceback):
        """Possibly goes into loop to read debugger commands."""
        do_loop = self.setup(frame, traceback) != 1
        if do_loop:
            self.print_location()
            self.display.displayAny(self.curframe)
            if not self.noninteractive:
                try:
                    self.cmdloop()
                except KeyboardInterrupt:
                    self.do_quit(None)
        self.currentbp = None    # Can forget it now that we're moving on
        self.forget()
        if not do_loop:
            return 1

    def msg(self, msg):
        """Common routine for reporting messages.
           Derived classed may want to override this to capture output.
           """
        print "%s" % msg

    def msg_nocr(self, msg):
        """Common routine for reporting messages (no carriage return).
           Derived classed may want to override this to capture output.
           """
        print "%s" % msg,

    def precmd(self, line):
        """Handle alias expansion and ';;' separator."""
        if not line.strip():
            return line
        args = line.split()
        while args[0] in self.aliases:
            line = self.aliases[args[0]]
            ii = 1
            for tmpArg in args[1:]:
                line = line.replace("%" + str(ii),
                                      tmpArg)
                ii = ii + 1
            line = line.replace("%*", ' '.join(args[1:]))
            args = line.split()
        # split into ';;' separated commands
        # unless it's an alias command
        if args[0] != 'alias':
            marker = line.find(';;')
            if marker >= 0:
                # queue up everything after marker
                next = line[marker+2:].lstrip()
                self.cmdqueue.append(next)
                line = line[:marker].rstrip()
        return line

    def print_location(self, prompt_prefix=line_prefix):
        """Show where we are. GUI's and front-end interfaces often
        use this to update displays. So it is helpful to make sure
        we give at least some place that's located in a file.      
        """
        i_stack = self.curindex
        while i_stack >= 0:
            frame_lineno = self.stack[i_stack]
            i_stack -= 1
            frame, lineno = frame_lineno
            filename = self.filename(self.canonic_filename(frame))
            self.msg_nocr('(%s:%s):' % (filename, lineno))
            fn_name = frame.f_code.co_name
            if fn_name and fn_name != '?':
                self.msg(" %s" % frame.f_code.co_name)
            else:
                self.msg("")

            # If we are stopped at an "exec" or print the next outer
            # location for that front-ends tracking source execution.
            if not is_exec_stmt(frame):
                break

    def print_stack_entry(self, i_stack):
        frame_lineno = self.stack[len(self.stack)-i_stack-1]
        frame, lineno = frame_lineno
        if frame is self.curframe:
            self.msg_nocr('->')
        else:
            self.msg_nocr('##')
        self.msg("%d %s" %
                 (i_stack, self.format_stack_entry(frame_lineno)))

    def print_stack_trace(self):
        i=len(self.stack)
        try:
            for i in range(len(self.stack)):
                self.print_stack_entry(i)
        except KeyboardInterrupt:
            pass

    def reset(self):
        bdb.Bdb.reset(self)
        self.forget()

    def setup(self, frame, traceback=None):
        """Initialization done before entering the debugger-command
        loop. We return 1 if we should NOT enter the debugger-command
        loop."""
        self.forget()
        self.stack, self.curindex = self.get_stack(frame, traceback)
        self.curframe = self.stack[self.curindex][0]
        if self.execRcLines()==1: return 1

    def setup_source(self, arg, showError=False):
        """Set up to read commands from a source file"""
        try:
            rcFile = open(os.path.join(arg))
        except IOError, (errno, strerror):
            if showError:
                self.errmsg("Error opening debugger command file %s: %s"
                            % (arg, strerror))
            pass
        else:
            for line in rcFile.readlines():
                self.rcLines.append(line)
            rcFile.close()

    # Override Bdb methods

    def user_call(self, frame, argument_list):
        """This method is called when there is the remote possibility
        that we ever need to stop in this function."""
        self.stop_reason = 'call'
        if self._wait_for_mainpyfile:
            return
        if self.stop_here(frame):
            self.msg('--Call--')
            if self.linetrace:
                self.__print_location_if_linetrace(frame)
                if not self.break_here(frame): return
            self.interaction(frame, None)

    def user_exception(self, frame, (exc_type, exc_value, exc_traceback)):
        """This function is called if an exception occurs,
        but only if we are to stop at or just below this level."""

        self.stop_reason = 'exception'
        # Remove any pending source lines.
        self.rcLines = []

        frame.f_locals['__exception__'] = exc_type, exc_value
        if type(exc_type) == types.StringType:
            exc_type_name = exc_type
        else: exc_type_name = exc_type.__name__
        self.msg("%s:%s" % (str(exc_type_name), str(_saferepr(exc_value))))
        self.interaction(frame, exc_traceback)

    def user_line(self, frame):
        """This function is called when we stop or break at this line."""
        # print "+++ user_line here"
        self.stop_reason = 'line'
        if self._wait_for_mainpyfile:
            if (self.mainpyfile != self.canonic_filename(frame)
                or inspect.getlineno(frame) <= 0):
                return
            self._wait_for_mainpyfile = False

        if self.stop_here(frame) or self.linetrace:
            # Don't stop if we are looking at a def for which a breakpoint
            # has not been set.
            import linecache
            filename = self.filename(self.canonic_filename(frame))
            line = linecache.getline(filename, inspect.getlineno(frame))
            global step_ignore_count
            # No don't have a breakpoint. So we are either
            # stepping or here be of line tracing.
            if step_ignore_count > 0:
                # Don't stop this time, just note a step was done in
                # step count
                step_ignore_count -= 1
                self.__print_location_if_linetrace(frame)
                return
            elif step_ignore_count < 0:
                # We are stepping only because we tracing
                self.__print_location_if_linetrace(frame)
                return
            if not self.break_here(frame):
                if is_def_stmt(line, frame):
                   self.__print_location_if_linetrace(frame)
                   return
        else:
            if not self.break_here(frame) and step_ignore_count > 0:
                self.__print_location_if_linetrace(frame)
                step_ignore_count -= 1
                return
        self.interaction(frame, None)

    def user_return(self, frame, return_value):
        """This function is called when a return trap is set here."""
        self.stop_reason = 'return'
        frame.f_locals['__return__'] = return_value
        self.msg('--Return--')
        self.stop_reason = 'return'
        self.__print_location_if_linetrace(frame)
        if self.returnframe != None:
            self.interaction(frame, None)

    ###################################################################
    # Command definitions, called by cmdloop()
    # The argument is the remaining string on the command line
    # Return true to exit from the command loop
    ###################################################################

    do_h = cmd.Cmd.do_help

    def do_alias(self, arg):
        """alias [name [command [parameter parameter ...] ]]
Creates an alias called 'name' the executes 'command'.  The command
must *not* be enclosed in quotes.  Replaceable parameters are
indicated by %1, %2, and so on, while %* is replaced by all the
parameters.  If no command is given, the current alias for name
is shown. If no name is given, all aliases are listed.

Aliases may be nested and can contain anything that can be
legally typed at the debugger prompt.  Note!  You *can* override
internal debugger commands with aliases!  Those internal commands
are then hidden until the alias is removed.  Aliasing is recursively
applied to the first word of the command line; all other words
in the line are left alone.

Some useful aliases (especially when placed in the .%src file) are:

#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]

#Print instance variables in self
alias ps pi self
""" % _debugger_name
        args = arg.split()
        if len(args) == 0:
            keys = self.aliases.keys()
            keys.sort()
            for alias in keys:
                self.msg("%s = %s" % (alias, self.aliases[alias]))
            return
        if args[0] in self.aliases and len(args) == 1:
            self.msg("%s = %s" % (args[0], self.aliases[args[0]]))
        else:
            self.aliases[args[0]] = ' '.join(args[1:])

    def do_break(self, arg, temporary = 0):
        """b(reak) {[file:]lineno | function} [, condition]
With a line number argument, set a break there in the current
file.  With a function name, set a break at first executable line
of that function.  Without argument, list all breaks.  If a second
argument is present, it is a string specifying an expression
which must evaluate to true before the breakpoint is honored.

The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that
hasn't been loaded yet).  The file is searched for on sys.path;
the .py suffix may be omitted."""

        cond = None
        funcname = None
        if not arg:
            if self.lineno is None:
                lineno = max(1, inspect.getlineno(self.curframe))
            else:
                lineno = self.lineno + 1
            filename = self.curframe.f_code.co_filename
        else:
            # parse arguments; comma has lowest precedence
            # and cannot occur in filename
            filename = None
            lineno = None
            comma = arg.find(',')
            if comma > 0:
                # parse stuff after comma: "condition"
                cond = arg[comma+1:].lstrip()
                arg = arg[:comma].rstrip()
            # parse stuff before comma: [filename:]lineno | function
            # Make sure it works for "clear C:\foo\bar.py:12"
            colon = arg.rfind(':')
            if colon >= 0:
                filename = arg[:colon].rstrip()
                f = self.lookupmodule(filename)
                if not f:
                    self.errmsg("%s not found from sys.path" % repr(filename))
                    return
                else:
                    filename = f
                arg = arg[colon+1:].lstrip()
                try:
                    lineno = int(arg)
                except ValueError, msg:
                    self.errmsg('Bad lineno: %s', str(arg))
                    return
            else:
                # no colon; can be lineno or function
                (funcname, filename, lineno) = self.__get_brkpt_lineno(arg)
                if lineno is None: return
                
        # FIXME This default setting doesn't match that used in
        # do_clear. Perhaps one is non-optimial.
        if not filename:
            filename = self.defaultFile()

        # Check for reasonable breakpoint
        line = self.checkline(filename, lineno)
        if line:
            # now set the break point
            # Python 2.3.5 takes 5 args rather than 6.
            # There's probably a way in configure to test for the version,
            # but this works too.
	    try:
	       err = self.set_break(filename, line, temporary, cond, funcname)
	    except TypeError:
	       err = self.set_break(filename, line, temporary, cond)

            if err: self.errmsg(err)
            else:
                bp = self.get_breaks(filename, line)[-1]
                self.msg("Breakpoint %d set in file %s, line %d."
                         % (bp.number, self.filename(bp.file), bp.line))

    do_b = do_break

    def do_cd(self, arg):
        """Set working directory to DIRECTORY for debugger and program
	being debugged. """

        if not arg:
            self.errmsg("Argument required (new working directory).")
        else:
           os.chdir(arg)

    def do_clear(self, arg):
        """cl(ear) {[file:]linenumber | function}

        Clear breakpoint at specified line or function.  Argument may
        be line number, function name, or '*' and an address.  If line
        number is specified, all breakpoints in that line are cleared.
        If function is specified, breakpoints at beginning of function
        are cleared.  If an address is specified, breakpoints at that
        address are cleared.

        With no argument, clears all breakpoints in the line that the
        selected frame is executing in.

        See also the 'delete' command which clears breakpoints by number.
        """

        if not arg:
            frame, lineno = self.stack[self.curindex]
            filename = self.canonic_filename(self.curframe)

        else:
            if ':' in arg:
                # Make sure it works for "clear C:\foo\bar.py:12"
                i = arg.rfind(':')
                filename = arg[:i]
                arg = arg[i+1:]
                try:
                    lineno = int(arg)
                except:
                    self.errmsg("Invalid line number (%s)" % arg)
                    return
            else:
                (funcname, filename, lineno) = self.__get_brkpt_lineno(arg)
                    
            if lineno is None: return

            # FIXME This default setting doesn't match that used in
            # do_break. Perhaps one is non-optimial.
            if filename is None:
                filename = self.canonic_filename(self.curframe)
                    
        brkpts = self.clear_break(filename, lineno)

        if len(brkpts) > 0:
            if len(brkpts) == 1:
                self.msg("Deleted breakpoint %d" % brkpts[0])
            else:
                self.msg("Deleted breakpoints " +
                         ' '.join(map(lambda b: str(b), brkpts)))
        return

    do_cl = do_clear

    def do_condition(self, arg):
        """condition bpnumber str_condition

        str_condition is a string specifying an expression which must
        evaluate to true before the breakpoint is honored.  If
        str_condition is absent, any existing condition is removed;
        i.e., the breakpoint is made unconditional."""

        args = arg.split(' ', 1)
        try:
            bpnum = self.__get_pos_int(args[0].strip(), min=1,
                                       cmdname='condition')
        except ValueError:
            return
        except IndexError:
            self.errmsg("Breakpoint number required.")
        try:
            cond = args[1]
        except:
            cond = None
        try:
            bp = bdb.Breakpoint.bpbynumber[bpnum]
        except IndexError:
            self.errmsg("No breakpoint number %d." % bpnum)
            return
        if bp:
            bp.cond = cond
            if not cond:
                self.msg('Breakpoint %d is now unconditional.' % bpnum)

    # Note: ddd only uses first line of docstring after the command name.
    # That is the part that starts Continue execution...
    # So make sure this is a complete sentence.
    def do_continue(self, arg):
        """c(ont(inue))

        Continue execution; only stop when a breakpoint is encountered."""

        if self.linetrace:
            # linetracing is like stepping, but we just don't stop. If
            # we were to calling set_continue, it  *might* remove all
            # stopping if there were no breakpoints.
            global step_ignore_count
            step_ignore_count = -1
            self.set_step()
        else:
            self.set_continue()
        return 1
    do_c = do_cont = do_continue

    def do_debug(self, arg):
        """debug code
        Enter a recursive debugger that steps through the code argument
        (which is an arbitrary expression or statement to be executed
        in the current environment)."""
        sys.settrace(None)
        globals = self.curframe.f_globals
        locals = self.curframe.f_locals
        p = Pdb()
        p.prompt  = "(%s) " % self.prompt.strip()
        self.msg("ENTERING RECURSIVE DEBUGGER")

        # Inherit some values from current environemnt
        p.aliases         = self.aliases
        p.basename        = self.basename
        p.cmdtrace        = self.cmdtrace
        p.gdb_dialect     = self.gdb_dialect
        p.linetrace       = self.linetrace
        p.linetrace_delay = self.linetrace_delay
        p.listsize        = self.listsize
        p.noninteractive  = self.noninteractive
        
        sys.call_tracing(p.run, (arg, globals, locals))
        self.msg("LEAVING RECURSIVE DEBUGGER")
        sys.settrace(self.trace_dispatch)
        self.lastcmd = p.lastcmd

    def do_delete(self, arg):

        """delete [bpnumber [bpnumber...]]  Delete some breakpoints.
        Arguments are breakpoint numbers with spaces in between.  To
        delete all breakpoints, give no argument.  those breakpoints.
        Without argument, clear all breaks (but first ask
        confirmation).
        
        See also the 'clear' command which clears breakpoints by
        line/file number.."""
        
        if not arg:
            while True and not self.noninteractive:
                try:
                    reply = raw_input('Delete all breakpoints (y or n)? ')
                except EOFError:
                    reply = 'no'
                    reply = reply.strip().lower()
                if reply in ('y', 'yes'):
                    self.clear_all_breaks()
                    break
                elif reply in ('n', 'no'):
                    return
                else:
                    self.msg("Please answer y or n.")

        numberlist = arg.split()
        for arg in numberlist:
            try:
                i = self.__get_pos_int(arg, min=1, default=None,
                                       cmdname='delete')
            except ValueError:
                continue

            if not (i < len(bdb.Breakpoint.bpbynumber)):
                self.errmsg('No breakpoint numbered %d.' % i)
                continue
            err = self.clear_bpbynumber(i)
            if err:
                self.errmsg(err)
            else:
                self.msg('Deleted breakpoint %d' % i)

    def do_disable(self, arg):
        """disable [display] bpnumber [bpnumber ...]

        Disables the breakpoints given as a space separated list of bp
        numbers."""

        args = arg.split()
        if len(args) == 0:
            self.errmsg('No breakpoint number given')
            return
        if args[0] == 'display':
            self.display_enable(args[1:], 0)
            return
        for i in args:
            try:
                i = int(i)
            except ValueError:
                self.msg('Breakpoint index %r is not a number' % i)
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                self.msg('No breakpoint numbered %d' % i)
                continue

            bp = bdb.Breakpoint.bpbynumber[i]
            if bp:
                bp.disable()

    def do_disassemble(self, arg):
        """disassemble [arg]
        With no argument disassemble at the current frame location.
        With a numeric argument, disassemble at the frame location at that
        line number. With a class, method, function, code or string argument
        disassemble that.
        """
        if not arg:
            dis.disassemble(self.curframe.f_code, self.curframe.f_lasti)
        else:
            try:
                i = int(arg)
                dis.disassemble(self.curframe.f_code, i)
            except ValueError:
                try: 
                    obj=self.__getval(arg)
                    dis.dis(obj)
                except NameError:
                    pass
        
    def do_display(self, arg):
        """display [format] EXP

	Print value of expression EXP each time the program stops.
	FMT may be used before EXP and may be one of 'c' for char, 
	'x' for hex, 'o' for ocatl, 'f' for float or 's' for string.

        With no argument, display all currently requested auto-display
        expressions.  Use "undisplay" to cancel display requests previously
        made."""

        if not arg:
            # Display anything active
            self.display.displayAny(self.curframe)
        else:
            # Set up a display
            arglist = arg.split()
            if len(arglist) == 2:
               format, variable = arglist
            else:
               format = ""
               variable = arglist[0]
            dp = DisplayNode(self.curframe, variable, format)
            res = dp.checkValid(self.curframe)
            print res
        return
    
    def do_down(self, arg):
        """d(own) [count]

        Move the current frame one level down in the stack trace
        (to a newer frame).

        If using gdb dialect up matches the gdb: 0 is the most recent
        frame.  Otherwise we match Python's stack: 0 is the oldest
        frame.  """

        try:
            count = self.__get_int(arg, cmdname="down")
        except ValueError:
            return
        if self.gdb_dialect:
            count = -count
        self.__adjust_frame(pos=-count, absolute_pos=False)
    do_d = do_down

    def do_enable(self, arg):

        """enable [display] bpnumber [bpnumber ...]]

        Enables the breakpoints given as a space separated list of bp
        numbers."""

        args = arg.split()
        if len(args) == 0:
            self.errmsg('No breakpoint number given')
            return

        if args[0] == 'display':
            self.display_enable(args[1:], True)
            return

        for i in args:
            try:
                i = int(i)
            except ValueError:
                self.msg('Breakpoint index %r is not a number' % i)
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                self.errmsg('No breakpoint numbered %d' % i)
                continue

            bp = bdb.Breakpoint.bpbynumber[i]
            if bp:
                bp.enable()

    def do_examine(self, arg):
        """examine expression
        Print the type of the expression and prettyprint its value.
	For functions, methods, classes and modules we print out the
	documentation string if any.

	For functions we also show the argument list."""

        try: 
            obj = self.__getval(arg)
        except:
            return
        if inspect.isfunction(obj):
            # For functions we print the fn(args) and doc if it exists
            self.msg("def %s%s:" % 
                     (arg, inspect.formatargspec(inspect.getargspec(obj)[0])))
            doc=inspect.getdoc(obj)
            if doc != None and doc != '': 
                self.msg(doc)
            self.msg(repr(obj))
        elif inspect.ismodule(obj) or inspect.isbuiltin(obj) \
                or inspect.isclass(obj):
            self.msg(repr(obj))
            doc=inspect.getdoc(obj)
            if doc != None and doc != '': 
                self.msg(doc)
        else:
            self.do_whatis(arg)
            self.do_pp(arg)

#    def do_file(self, fname):
#
#        """ Use FILE as program to be debugged.  It is compiled and
#        becomes is the program executed when you use the `run'
#        command.  If FILE cannot be found as specified, your execution
#        directory path ($PATH) is searched for a command of that name.
#        No arg means to have no executable file and no symbols."""
#
#        if fname == "":
#            if self.mainpyfile == "":
#                print 'No exec file now.\nNo symbol file now.'
#                return
#            else:
#                # should confirm this per
#                #Discard symbol table from `/work/.../ddd/cxxtest'? (y or n) n
#                # XXX 
#                # del module
#                sys.path = self.originalpath[:]
#                self.mainpyfile == ""
#        else:
#            path, module = os.path.split(fname)
#            module = module.split('.')[0]
#            sys.path = self.originalpath[:]
#            sys.path.insert(0, path)
#            # XXX how to clean up name space ??
#            if self.moduletodebug:
#                try:
#                    # del self.moduletodebug
#                    self.moduletodebug = ''
#                except:
#                    pass
#            line = "import " + module + '\n'
#            code = compile(line, '<stdin>', 'single')
#            globals = self.curframe.f_globals
#            locals = self.curframe.f_locals
#            exec code in globals, locals
#            # Could print 'Reading symbols from fname...done.' for gdb conformance
#            self.mainpyfile = fname
#            self.moduletodebug = module

    def do_finish(self, arg):
        """finish

        Continue execution until the current function returns."""

        self.set_return(self.curframe)
        if self.linetrace:
            global step_ignore_count
            step_ignore_count = -1
            self.stopframe = None
        return 1

    def do_frame(self, arg):
        """frame frame-number
	Move the current frame to the specified frame number. 

	If using gdb dialect up matches the gdb: 0 is the most recent
	frame.  Otherwise we match Python's stack: 0 is the oldest
	frame.

	A negative number indicates position from the other end.
	So 'frame -1' moves when gdb dialect is in effect moves
	to the oldest frame, and 'frame 0' moves to the newest frame."""

        try:
            arg = int(arg)
        except ValueError:
            self.errmsg(("The 'frame' command requires a frame number."+
                         " Got: %s") % arg)
            return

        i_stack = len(self.stack)
        if arg < -i_stack or arg > i_stack-1:
            self.errmsg('Frame number has to be in the range %d to %d' \
                  % (-i_stack, i_stack-1))
        else:
            self.__adjust_frame(pos=arg, absolute_pos=True)

    ### This Comes from cmd.py 
    ### FIXME: consider putting in pydb cmd class.
    ### Move self.nohelp along with this?
    def do_help(self, arg):
        """Without argument, print the list of available commands.
        With a command name as argument, print help about that command
        'help *cmd*' pipes the full documentation file to the $PAGER
        'help exec gives help on the ! command"""
        if arg:
            first_arg = arg.split()[0]
            try:
                func = getattr(self, 'help_' + first_arg)
                func(arg.split()[1:])
            except AttributeError:
                try:
                    doc=getattr(self, 'do_' + first_arg).__doc__
                    if doc:
                        self.msg("%s\n" % str(doc))
                        return
                except AttributeError:
                    pass
                self.msg("%s\n" % str(self.nohelp % (first_arg,)))
                return
        else:
            names = self.get_names()
            cmds_doc = []
            cmds_undoc = []
            help = {}
            for name in names:
                if name[:5] == 'help_':
                    help[name[5:]]=1
            names.sort()
            # There can be duplicates if routines overridden
            prevname = ''
            for name in names:
                if name[:3] == 'do_':
                    if name == prevname:
                        continue
                    prevname = name
                    cmd=name[3:]
                    if cmd in help:
                        cmds_doc.append(cmd)
                        del help[cmd]
                    elif getattr(self, name).__doc__:
                        cmds_doc.append(cmd)
                    else:
                        cmds_undoc.append(cmd)
            self.msg("%s\n" % str(self.doc_leader))
            self.print_topics(self.doc_header,   cmds_doc,   15,80)
            self.print_topics(self.misc_header,  help.keys(),15,80)
            self.print_topics(self.undoc_header, cmds_undoc, 15,80)

    def do_ignore(self,arg):

        """ignore bpnumber count

        Sets the ignore count for the given breakpoint number.  A
        breakpoint becomes active when the ignore count is zero.  When
        non-zero, the count is decremented each time the breakpoint is
        reached and the breakpoint is not disabled and any associated
        condition evaluates to true."""

        args = arg.split()
        bpnum = int(args[0].strip())
        try:
            count = int(args[1].strip())
        except:
            count = 0
        bp = bdb.Breakpoint.bpbynumber[bpnum]
        if bp:
            bp.ignore = count
            if count > 0:
                reply = 'Will ignore next '
                if count > 1:
                    reply = reply + '%d crossings' % count
                else:
                    reply = reply + '1 crossing'
                self.msg('%s of breakpoint %d.' % (reply, bpnum))
            else:
                self.msg('Will stop next time breakpoint %d is reached.' %
                         bpnum)

    def do_info(self, arg):
        """i(nfo) [suboption]
	Without argument, print the list of available info commands.
	With an argument, print info about that command. Suboptions follow:

        info args -- Argument variables of current stack frame
        info display -- Expressions to display when program stops,
                        with code numbers.
        info break -- Status of user-settable breakpoints
        info globals -- Global variables of current stack frame
        info line -- Current line number in source file
        info locals -- Local variables of current stack frame
        info program -- Execution status of the program
        info source -- Information about the current Python file"""

        if not arg:
            self.msg(self.do_info.__doc__)
            return

        arglist = arg.split()
        arg = arglist[0]
        frame=self.curframe
        if "args" == arg:
            self.__info_args(None)
        elif "break" == arg:
            # FIXME: Should split out the "info" part in args
            self.do_L(None)
        elif 'display' == arg:
            if not self.display.displayAll():
                self.msg('There are no auto-display expressions now.')
        elif "globals" == arg:
            self.msg("\n".join(["%s = %s"
                                % (l, pprint.pformat(self.__getval(l)))
                                for l in frame.f_globals]))
        elif "line" == arg:
            #info line identifier
            if len(arglist) == 2:
                # lineinfo returns (item, file, lineno) or (None,)
                answer = self.lineinfo(arglist[1])
                if answer[0]:
                    item, file, lineno = answer
                    self.msg('Line %s of "%s" <%s>' %
                             (lineno, file, item))
                return
            #info line
            self.msg('Line %d of \"%s\" at instruction %d' % 
                     (inspect.getlineno(frame),
                      self.filename(self.canonic_filename(frame)),
                     self.curframe.f_lasti))
        elif "locals" == arg:
            self.msg("\n".join(["%s = %s"
                                % (l, pprint.pformat(self.__getval(l)))
                                for l in frame.f_locals]))
        elif 'program' == arg:
            if not self.running:
                self.msg('The program being debugged is not being run.')
            else:
                self.msg('Program stopped.')
                if self.currentbp:
                    self.msg('It stopped at breakpoint %d.' % self.currentbp)
                elif self.stop_reason == 'call':
                    self.msg('It stopped at a call.')
                elif self.stop_reason == 'exception':
                    self.msg('It stopped as a result of an exception.')
                elif self.stop_reason == 'return':
                    self.msg('It stopped at a return.')
                else:
                    self.msg("It stopped after stepping, next'ing or initial start.")
            return
        elif "source" == arg:
            self.msg('Current Python file is %s' %
                     self.filename(self.canonic_filename(frame)))
        else:
            self.errmsg("Unknown info subcommand %s" % arg)

    def info_break(self, arg):
        """info break

        Without argument, list info about all breakpoints.  With an
        integer argument, list info on that breakpoint.

        The short command name is L."""

        if self.breaks:  # There's at least one
            self.msg("Num Type          Disp Enb    Where")
            for bp in bdb.Breakpoint.bpbynumber:
                if bp:
                    self.bpprint(bp)
        else:
            self.msg("No breakpoints.")

    do_L = info_break

    def do_jump(self, arg, cmdname='Jump'):
        """j(ump) lineno

        Set the next line that will be executed."""

        if self.curindex + 1 != len(self.stack):
            self.errmsg("You can only jump within the bottom frame")
            return
        try:
            arg = int(arg)
        except ValueError:
            self.errmsg("The 'jump' command requires a line number.")
        else:
            try:
                # Do the jump, fix up our copy of the stack, and display the
                # new position
                self.curframe.f_lineno = arg
                self.stack[self.curindex] = self.stack[self.curindex][0], arg
                self.print_location()
            except ValueError, e:
                self.errmsg('%s failed: %s' % (cmdname, e))

    do_j = do_jump

    def do_list(self, arg):
        """l(ist) [first [,last]]
        List source code for the current file.
        Without arguments, list 11 lines around the current line
        or continue the previous listing.
        With one argument, list 11 lines starting at that line.
        With two arguments, list the given range;
        if the second argument is less than the first, it is a count."""
        self.lastcmd = 'list'
        last = None
        if arg:
            try:
                x = eval(arg, {}, {})
                if type(x) == type(()):
                    first, last = x
                    first = int(first)
                    last = int(last)
                    if last < first:
                        # Assume it's a count
                        last = first + last
                else:
                    first = max(1, int(x) - 5)
            except:
                self.errmsg('Error in argument: %s' % repr(arg))
                return
        elif self.lineno is None or not self.running:
            first = max(1, inpsect.getlineno(self.curframe) - 5)
        else:
            first = self.lineno + 1
        if last is None:
            last = first + self.listsize
        filename = self.curframe.f_code.co_filename
        breaklist = self.get_file_breaks(filename)
        try:
            for lineno in range(first, last+1):
                line = linecache.getline(filename, lineno)
                if not line:
                    self.msg('[EOF]')
                    break
                else:
                    s = repr(lineno).rjust(3)
                    if len(s) < 4: s = s + ' '
                    if lineno in breaklist: s = s + 'B'
                    else: s = s + ' '
                    if lineno == inpect.getlineno(self.curframe):
                        s = s + '->'
                    self.msg_nocr(s + '\t' + line)
                    self.lineno = lineno
        except KeyboardInterrupt:
            pass
    do_l = do_list

    def do_next(self, arg):
        """n(ext) [count]
Continue execution until the next line in the current function is reached or it returns.

With an integer argument, perform that many times."""
        global step_ignore_count
        try:
            # 0 means stop now or step 1, so we subtract 1.
            step_ignore_count = self.__get_pos_int(arg, default=1,
                                                   cmdname='next') - 1
        except ValueError:
            return

        self.set_next(self.curframe)
        return 1
    do_n = do_next

    def do_p(self, arg):
        """p expression
        Print the value of the expression."""
        try:
            self.msg(repr(self.__getval(arg)))
        except:
            pass

    def do_pp(self, arg):
        """pp expression
        Pretty-print the value of the expression."""
        try:
            self.msg(pprint.pformat(self.__getval(arg)))
        except:
            pass

    def do_pwd(self, arg):
        "Print working directory."
        self.msg('Working directory ' + os.getcwd() + '.')

    def do_quit(self, arg):
        """q(uit) or exit - Quit from the debugger.
        The program being executed is aborted."""
        self._user_requested_quit = True
        self.running              = False
        self.set_quit()
        return 1

    do_q = do_quit

    def do_restart(self, arg):

        """restart
        Restart debugger and program via an exec call. All state
        is lost, and new copy of the debugger is used."""

        self.msg("Re exec'ing\n\t%s" % self._sys_argv)
        os.execvp(self._sys_argv[0], self._sys_argv)
        

    def do_return(self, arg):

        """Make selected stack frame return to its caller. Control
        remains in the debugger, but when you continue execution will
        resume at the return statement found inside the subroutine or
        method.  At present we are only able to perform this if we are
        in a subroutine that has a 'return' statement in it.  """

        frame = self.curframe

        if '?' == frame.f_code.co_name and not '__args__' in frame.f_locals:
            self.errmsg("I don't see that we are in a subroutine.")
            return

        while True and not self.noninteractive:
            try:
                # reply = raw_input('Make %s return now? (y or n) ')
                reply = raw_input('Return now? (y or n) ')
            except EOFError:
                reply = 'no'
                reply = reply.strip().lower()
            if reply in ('y', 'yes'):
                break
            elif reply in ('n', 'no'):
                return
            else:
                self.msg("Please answer y or n.")

        co = frame.f_code
        code = co.co_code
        labels = dis.findlabels(code)
        linestarts = dict(dis.findlinestarts(co))

        i=frame.f_lasti
        last_stmt = i
        last_line = inspect.getlineno(frame)
        # print "++i: %d, len(code): %d" % (i, len(code))
        while i < len(code):
            i += 1
            if i in labels:
                # print "++last_stmt %d" % i
                last_stmt = i
                last_line = None
            if i in linestarts and i > 0:
                # print "++last_line %d" % linestarts[i]
                last_line = linestarts[i]
            if 'RETURN_VALUE' == op_at_frame(frame, i):
                break

        if i == len(self.stack) or last_line is None:
            self.msg("Sorry; a return statement was not found.")
            return

        # print "++i: %d, last_stmt %d, line: %d " % (i, last_stmt, last_line)
        self.do_jump(last_line, "Return")

    def do_retval(self, arg):

        """retval
Show the value that is to be returned from a
function.  This command is useful after a "finish" command or stepping
just after a "return" statement. To change the value, make an assignment
to the variable __return__."""

        if '__return__' in self.curframe.f_locals:
            self.msg(self.curframe.f_locals['__return__'])
        else:
            self.errmg('Not yet returned!')
    do_rv = do_retval

    def do_run(self, arg):
        """run [args...]

        Run/Restart the debugged Python program. If a string is
        supplied that becomes the new command arguments.  History,
        breakpoints, actions and debugger options are preserved."""

        if arg:
            argv_start = self._program_sys_argv[0:1]
            self._program_sys_argv = arg.split(" ")
            self._program_sys_argv[:0] = argv_start

        raise Restart

    do_R = do_run

    def do_set(self, arg):
        """See help_set"""
        args = arg.split()
        if len(args) < 2:
            self.errmsg("Expecting at least 2 arguments. Got %d" % len(args))
            return
        if args[0] == 'args':
            argv_start = self._program_sys_argv[0:1]
            if arg:
                self._program_sys_argv = arg.split(" ")[1:]
            else:
                self._program_sys_argv = []
            self._program_sys_argv[:0] = argv_start

        elif args[0] == 'basename':
            try:
                self.basename = self.__get_onoff(args[1])
            except ValueError:
                pass

        elif args[0] == 'cmdtrace':
            try:
                self.cmdtrace = self.__get_onoff(args[1])
            except ValueError:
                pass
        elif args[0] == 'interactive':
                self.noninteractive = not self.__get_onoff(args[1])
        elif args[0] == 'linetrace':
            if args[1]=='delay':
                try:
                    delay = float(args[2])
                    self.linetrace_delay = delay
                except IndexError:
                    self.errmsg("Need a 3rd floating-point number")
                except ValueError:
                    self.errmsg(("3rd argument %s is not a floating-point "
                                 + "number") % str(args[2]) )
            else:
                try:
                    self.linetrace = self.__get_onoff(args[1])
                except ValueError:
                    pass
            
        elif args[0] == 'listsize':
            try:
                self.listsize = self.__get_int(args[1])
            except ValueError:
                pass
        elif args[0] == 'prompt':
            # Use the original prompt so we keep spaces and punctuation
            # just skip over the work prompt.
            re_prompt = re.compile(r'\s*prompt\s(.*)$')
            mo = re_prompt.search(arg)
            if mo:
                self.prompt = mo.group(1)
            else:
                self.errmsg("Something went wrong trying to find the prompt")
        else:
            self.errmsg("unknown set subcommand %s" %  args[0])

    def do_shell(self, arg):
        """Execute the rest of the line as a shell command."""
        os.system(arg)

    def do_show(self, arg):
        """Generic command for showing things about the debugger."""
        if not arg:
            for subcommand in ['args', 'basename', 'cmdtrace', 'linetrace', 
                               'linetrace delay', 'listsize', 'prompt',
                               'version']:
                self.msg_nocr("%s: " % subcommand)
                self.do_show(subcommand)
            return

        if arg == 'args':
            self.msg("Argument list to give program being debugged " +
                      "when it is started is ")
            self.msg('"%s".' % " ".join(self._program_sys_argv[1:]))
        elif arg == 'basename':
            self.msg("basename is %s." % show_onoff(self.basename))
        elif arg == 'cmdtrace':
            self.msg("cmdtrace is %s." % show_onoff(self.cmdtrace))
        elif arg == 'interactive':
            self.msg("interactive is %s." %
                     show_onoff(not self.noninteractive))
        elif arg == 'linetrace':
            self.msg("line tracing is %s." % show_onoff(self.linetrace))
        elif _re_linetrace_delay.match(arg):
            self.msg("line trace delay is %s. (In seconds)"
                     % self.linetrace_delay)
        elif arg == 'listsize':
            self.msg("Number of source lines %s will list by default is %d." \
                  % (_debugger_name, self.listsize))
        elif arg == 'prompt':
            self.msg("""%s's prompt is "%s".""" %
                     (_debugger_name, self.prompt))
        elif arg == 'version':
            self.msg("""%s version %s.""" %
                     (_debugger_name, "@PACKAGE_VERSION@"))
        else:
            self.errmsg('unknown show subcommand "%s"' % arg)

    def do_source(self, arg):
        """source FILE
        Read commands from a file named FILE.
        Note that the file file '.%pydbrc' is read automatically
        in this way when pydb is started.

        An error in any command terminates execution of the command
        file and control is returned to the console."""
        self.setup_source(os.path.expanduser(arg), True);
        rc = self.execRcLines() 
        if rc == 1:  return rc

    def do_step(self, arg):
        """s(tep) [count]
Execute the current line, stop at the first possible occasion
(either in a function that is called or in the current function).

With an integer argument, step that many times."""

        global step_ignore_count
        try:
            # 0 means stop now or step 1, so we subtract 1.
            step_ignore_count = self.__get_pos_int(arg, default=1,
                                                   cmdname='step') - 1
        except ValueError:
            return

        self.set_step()
        return 1
    do_s = do_step

    def do_tbreak(self, arg):
        """tbreak  [ ([filename:]lineno | function) [, condition] ]
        Set a temporary breakpoint. Arguments are like the "break" command.
        Like "break" except the breakoint is only temporary, 
        so it will be deleted when hit."""
        self.do_break(arg, 1)

    def do_unalias(self, arg):
        """unalias name
Deletes the specified alias."""
        args = arg.split()
        if len(args) == 0: return
        if args[0] in self.aliases:
            del self.aliases[args[0]]

    # Print a traceback starting at the top stack frame.
    # The most recently entered frame is printed last;
    # this is different from dbx and gdb, but consistent with
    # the Python interpreter's stack trace.
    # It is also consistent with the up/down commands (which are
    # compatible with dbx and gdb: up moves towards 'main()'
    # and down moves towards the most recent stack frame).

    def do_undisplay(self, arg):
        """Cancel some expressions to be displayed when program stops.
        Arguments are the code numbers of the expressions to stop displaying.
        No argument means cancel all automatic-display expressions.
        "delete display" has the same effect as this command.
        Do "info display" to see current list of code numbers."""

        if arg:
            args = arg.split()
            for i in args:
                try:
                    i = int(i)
                    self.display.deleteOne(i)
                except ValueError:
                    self.errmsg('index %r is not a number' % i)
        else:
            self.display.deleteAll()

    def do_up(self, arg):
        """u(p) [count]
        Move the current frame one level up in the stack trace
        (to an older frame).
        
        If using gdb dialect up matches the gdb: 0 is the most recent
        frame.  Otherwise we match Python's stack: 0 is the oldest
        frame.  """

        try:
            count = self.__get_int(arg, cmdname="up")
        except ValueError:
            return
        if self.gdb_dialect:
            count = -count
        self.__adjust_frame(pos=count, absolute_pos=False)
    do_u = do_up

    def do_whatis(self, arg):
        """whatis arg
Prints the type of the argument which can be a Python expression."""
        try:
            value = eval(arg, self.curframe.f_globals,
                         self.curframe.f_locals)
        except:
            t, v = sys.exc_info()[:2]
            if type(t) == types.StringType:
                exc_type_name = t
            else: exc_type_name = t.__name__
            self.errmsg("%s: %s" % (exc_type_name, repr(v)))
            return
        code = None
        # Is it a function?
        try: code = value.func_code
        except: pass
        if code:
            self.msg('Function %s' % code.co_name)
            return
        # Is it an instance method?
        try: code = value.im_func.func_code
        except: pass
        if code:
            self.msg('Method %s' % code.co_name)
            return
        # None of the above...
        self.msg(type(value))

    def do_where(self, arg):
        """where

        Print a stack trace, with the most recent frame at the top.
        An arrow indicates the 'current frame', which determines the
        context of most commands.  'bt' and 'T' are short command
        names for this."""

        self.print_stack_trace()

    do_T = do_bt = do_where

    def do_EOF(self, arg):
        """EOF
Handles the receipt of EOF as a command."""
        self.msg("")
        self._user_requested_quit = True
        self.set_quit()
        return 1

    # Help methods (derived from pydb.doc or vice versa)

    for fn in ('EOF',     'L',         'alias',       'break',
               'cd',      'clear',     'condition',   'continue',
               'debug',   'disable',   'delete'   ,   'disassemble',
               'display', 'down',      'enable',      'examine',
               'finish',  'frame',     'help',
               'ignore',  'info',      'jump',        'list',
               'next',    'p',         'pp',          'pwd',    'quit',
               'restart', 'retval',    'run',
               'set',     'show',      'shell',       'source', 'step', 
               'tbreak',  'unalias',   'undisplay',   'up',
               'whatis',  'where'):
        exec 'def help_%s(self, *arg): self.msg(getattr(self.do_%s, "__doc__"))' \
             % (fn, fn)

    # Is this the right way to do this? 
    help_h = help_help
    help_R = help_run
    help_bt = help_T = help_where

    def help_exec(self, *arg):
        self.msg("""(!) statement
        Execute the (one-line) statement in the context of
        the current stack frame.
        The exclamation point can be omitted unless the first word
        of the statement resembles a debugger command.
        To assign to a global variable you must always prefix the
        command with a 'global' command, e.g.:
        %sglobal list_options; list_options = ['-l']
        %s""" % (self.prompt, self.prompt))

    # Note: format of help is compatible with ddd.
    def help_info(self, *args):
        """Generic command for showing things about the program being debugged."""
        subcmds=("args", "break", "display", "globals", "line",
                 "locals", "program", "source")
        self.__help_subcommand('info', getattr(self, 'help_info').__doc__,
                               subcmds, self.__help_info, args[0])

    def help_pydb(self, *arg):
        help()

    # Note: format of help is compatible with ddd.
    def help_set(self, *args):
        """This command modifies parts of the debugger environment.
You can see these environment settings with the 'show' command."""
        subcmds=("args", "basename", "cmdtrace", "interactive",
                 "linetrace", "listsize", "prompt")
        self.__help_subcommand('set', getattr(self, 'help_set').__doc__,
                               subcmds, self.__help_set, args[0])

    # Note: format of help is compatible with ddd.
    def help_show(self, *args):
        """Generic command for showing things about the debugger."""
        subcmds=("args", "basename", "cmdtrace", "interactive",
                 "linetrace", "listsize", "prompt", "version")
        self.__help_subcommand('show', getattr(self, 'help_show').__doc__,
                               subcmds, self.__help_show, args[0])

    ####### End of help section ########
        
    def lookupmodule(self, filename):
        """Helper function for break/clear parsing -- may be overridden.

        lookupmodule() translates (possibly incomplete) file or module name
        into an absolute file name.
        """
        if os.path.isabs(filename) and  os.path.exists(filename):
            return filename
        f = os.path.join(sys.path[0], filename)
        if  os.path.exists(f) and self.canonic(f) == self.mainpyfile:
            return f
        root, ext = os.path.splitext(filename)
        if ext == '':
            filename = filename + '.py'
        if os.path.isabs(filename):
            return filename
        for dirname in sys.path:
            while os.path.islink(dirname):
                dirname = os.readlink(dirname)
            fullname = os.path.join(dirname, filename)
            if os.path.exists(fullname):
                return fullname
        return None

    def _runscript(self, filename):
        # When bdb sets tracing, a number of call and line events happens
        # BEFORE debugger even reaches user's code (and the exact sequence of
        # events depends on python version). So we take special measures to
        # avoid stopping before we reach the main script (see user_line and
        # user_call for details).
        self._wait_for_mainpyfile = True
        self.mainpyfile = self.canonic(filename)
        self._user_requested_quit = False

        # Start with fresh empty copy of globals and locals and tell the script
        # that it's being run as __main__ to avoid scripts being able to access
        # the pydb.py namespace.
        globals_ = {"__name__" : "__main__",
                    "__file__" : self.mainpyfile
                    }
        locals_ = globals_


        statement = 'execfile( "%s")' % filename
        self.running = True
        self.run(statement, globals=globals_, locals=locals_)

# Simplified interface

def run(statement, globals=None, locals=None):
    Pdb().run(statement, globals, locals)

def runeval(expression, globals=None, locals=None):
    return Pdb().runeval(expression, globals, locals)

def runctx(statement, globals, locals):
    # B/W compatibility
    run(statement, globals, locals)

def runcall(*args, **kwds):
    return Pdb().runcall(*args, **kwds)

def set_trace():
    Pdb().set_trace(sys._getframe().f_back)

def debugger():
    """Use this to in your program to invoke the interactive command
loop of the debugger."""
    try:
        raise Exception
    except:
        frame=inspect.currentframe()
        p = Pdb()
        p.reset()
        p._program_sys_argv = list(sys.argv)
        p._sys_argv = list(sys.argv)
        try:
            p.interaction(frame, sys.exc_traceback)
        except Restart:
            p.do_restart(None)

# Post-Mortem interface

def post_mortem(t):
    p = Pdb()
    p.reset()
    p.running = False
    while t.tb_next is not None:
        t = t.tb_next
    p.interaction(t.tb_frame, t)

def pm():
    post_mortem(sys.last_traceback)


# Main program for testing

TESTCMD = 'import x; x.main()'

def test():
    run(TESTCMD)

# print help
def help():
    doc_file='%s.doc' % _debugger_name
    for dirname in sys.path:
        fullname = os.path.join(dirname, doc_file)
        if os.path.exists(fullname):
            sts = os.system('${PAGER-more} '+fullname)
            if sts: self.errmsg('Pager exit status: %s' % str(sts))
            break
    else:
        print ("Sorry, can't find the help file '%s' along the "
                  + "Python search path") % doc_file

def main():
    """Routine which gets run if we were invoked directly"""

    pydb = Pdb()
    process_options(pydb, _debugger_name, program)

    # process_options has munged sys.argv to remove any options that
    # options that belong to this debugger. The original options to
    # invoke the debugger and script are in global sys_argv

    if len(sys.argv) == 0:
        print 'Error: you need to give a script name to debug'
        sys.exit(1)

    # Save the DEBUGGED programs arguments. This is in case
    # the debugged script munges these, we have a good copy to use
    # for restart
    pydb._program_sys_argv = list(sys.argv)

    mainpyfile = pydb._program_sys_argv[0] # Get script filename. 
    if not os.path.exists(mainpyfile):
        print 'Error:', mainpyfile, 'does not exist'
        sys.exit(1)

    # Replace pydb's dir with script's dir in front of module search path.
    sys.path[0] = os.path.dirname(mainpyfile)

    while True:

        # Run the debugged script over and over again until you get it
        # right.

        try:
            pydb._runscript(mainpyfile)
            if pydb._user_requested_quit:
                break
            if pydb.noninteractive: break
            pydb.msg("The program finished and will be restarted")
        except Restart:
            sys.argv = list(pydb._program_sys_argv)
            pydb.msg("Restarting %s with arguments:\n\t%s"
                     % (pydb.filename(mainpyfile),
                        " ".join(pydb._program_sys_argv[1:])))
        except SystemExit:
            # In most cases SystemExit does not warrant a post-mortem session.
            pydb.msg("The program exited via sys.exit(). Exit status: %s" %
                     str(sys.exc_info()[1]))
            pydb.running = False;
            if pydb.noninteractive: break
        except:
            traceback.print_exc()
            if pydb.noninteractive:
                pydb.errmsg("Uncaught exception.")
                break
            pydb.errmsg("Uncaught exception. Entering post mortem debugging")
            pydb.errmsg( "Running 'cont' or 'step' will restart the program")
            pydb.running = False;
            t = sys.exc_info()[2]
            while t.tb_next is not None:
                t = t.tb_next
            try:
                pydb.interaction(t.tb_frame,t)
            except Restart:
                sys.argv = list(pydb._program_sys_argv)
                pydb.msg("Restarting %s with arguments:\n\t%s"
                         % (pydb.filename(mainpyfile),
                            " ".join(pydb._program_sys_argv[1:])))
            else:
                pydb.msg("Post mortem debugger finished.")
                pydb.msg(mainpyfile + " will be restarted")
        global step_ignore_count
        step_ignore_count = 0

init()

# When invoked as main program, invoke the debugger on a script
if __name__=='__main__':
    main()

#
# Local variables:
#  mode: Python
# End:
