#!@PYTHON@ -t
"""$Id: pydb.py.in,v 1.70 2006/03/05 00:11:12 rockyb Exp $
A Python debugger. (See also @PACKAGE_NAME@.doc for documentation.)"""

_debugger_name = '@PACKAGE_NAME@'

# The name of the debugger we are currently going by.
_version = '@PACKAGE_VERSION@'

import atexit, dis, inspect, linecache, os, pprint
import bdb, re, sys, traceback, types

import pydbcmd, pydbbdb
from pydbdisp import Display, DisplayNode
from pydbfns import *
from repr import Repr

class Restart(Exception):
    """Causes a debugger to be restarted for the debugged Python program."""
    pass

__all__ = ["Pdb",     "help",
           "pm",      "post_mortem", "run",
           "runcall", "runctx",      "runeval",
           "set_trace"]

def init():
    global program, _repr, _saferepr
    global _re_linetrace_delay

    program = os.path.basename(sys.argv[0])

    # Create a custom safe Repr instance and increase its maxstring.
    # The default of 30 truncates error messages too easily.
    _repr = Repr()
    _repr.maxstring = 200
    _saferepr = _repr.repr

    _re_linetrace_delay = re.compile(r'\s*linetrace\s*')

# Interaction prompt line will separate file and call info from code
# text using value of line_prefix string.  A newline and arrow may
# be to your liking.  You can set it once pydb is imported using the
# command "pydb.line_prefix = '\n% '".
# line_prefix = ': '    # Use this to get the old situation back
line_prefix = '\n-> '   # Probably a better default

from pydbcmd import Cmd
from pydbbdb import Bdb
class Pdb(Bdb, Cmd):

    def __init__(self):
        pydbbdb.Bdb.__init__(self)
        pydbcmd.Cmd.__init__(self)

        self._wait_for_mainpyfile = False
        self.basename        = False
        self.currentbp       = None   # for "info program"
        self.display         = Display()
        self.gdb_dialect     = True   # Controls how stack is shown
        self.linetrace       = False
        self.linetrace_delay = 0
        self.listsize        = 10
        self.mainpyfile      = ''
        self.maxargstrsize   = 30     # max length to show of parameter string 
        self.moduletodebug   = ""
        self.noninteractive  = False
        self.originalpath    = sys.path[:]
        self._program_sys_argv = []   # sys.argv after pydb options stripped
        self.running         = False
        self.stop_reason     = None   # Why are we in the debugger?
        self._sys_argv       = []     # exec sys.argv, e.g. may include pydb 
        # Try to load readline if it exists
        try:
            import readline
            self.hist_last = 0
            self.hist_save = False
            readline.set_history_length(256)
            # Read history file and set up to write history file when we
            # exit. 
            global _debugger_name
            self.histfile = os.path.join(os.environ["HOME"],
                                         ".%shist" % _debugger_name)
            try:
                readline.read_history_file(self.histfile)
            except IOError:
                pass
            atexit.register(self.write_history_file)

        except ImportError:
            self.histfile = None

    def __adjust_frame(self, pos, absolute_pos):
        """Adjust stack frame by pos positions. If absolute_pos then
        pos is an absolute number. Otherwise it is a relative number.

        If self.gdb_dialect is True, the 0 position is the newest
        entry and doesn't match Python's indexing. Otherwise it does.

        A negative number indexes from the other end."""
        # Below we remove any negativity. At the end, pos will be
        # the new value of self.curindex.
        if absolute_pos:
            if self.gdb_dialect:
                if pos >= 0:
                    pos = len(self.stack)-pos-1
                else:
                    pos -= len(self.stack)
            elif pos < 0:
                pos = len(self.stack)+pos
        else:
            pos += self.curindex

        if pos < 0:
            self.errmsg("Adjusting would be put us beyond the oldest frame")
            return
        elif pos >= len(self.stack):
            self.errmsg("Adjusting would be put us beyond the newest frame")
            return

        self.curindex = pos
        self.curframe = self.stack[self.curindex][0]
        self.print_location()
        self.lineno = None

    def __get_brkpt_lineno(self, arg):
        """__get_brkpt_lineno(self,arg)->(fn, file, lineno)

        See if arg is a line number or a function name.  Return what
        we've found. None can be returned as a value in the triple."""
        funcname, filename = (None, None)
        try:
            # First try as an integer
            lineno = int(arg)
        except ValueError:
            try:
                func = eval(arg, self.curframe.f_globals,
                            self.curframe.f_locals)
            except:
                func = arg
            try:
                if hasattr(func, 'im_func'):
                    func = func.im_func
                code = func.func_code
                #use co_name to identify the bkpt (function names
                #could be aliased, but co_name is invariant)
                funcname = code.co_name
                lineno = code.co_firstlineno
                filename = code.co_filename
            except:
                # last thing to try
                (ok, filename, ln) = self.lineinfo(arg)
                if not ok:
                    self.errmsg(('The specified object %s is not'
                                 +' a function or was not found '
                                 +' along sys.path.') % str(repr(arg)))
                    return (None, None, None)
                funcname = ok # ok contains a function name
                lineno = int(ln)
        return (funcname, filename, lineno)

    def __help_info(self, cmd, label=False):
        """Show help for a single 'info' subcommand"""
        if label:
            self.msg_nocr("info %s --" % cmd)
        if cmd == 'args':
            self.msg("Argument variables of current stack frame")
        elif cmd == 'display':
            self.msg("Expressions to display when program stops, " +
                     "with code numbers.")
        elif cmd == 'break':
            self.msg("Status of user-settable breakpoints")
        elif cmd == 'globals':
            self.msg("Global variables of current stack frame")
        elif cmd == 'line':
            self.msg("Current line number in source file")
        elif cmd == 'locals':
            self.msg("Local variables of current stack frame")
        elif cmd == 'program':
            self.msg("Execution status of the program")
        elif cmd == 'source':
            self.msg("Information about the current Python file")
        else:
            self.undefined_cmd("help info", cmd)

    def __help_set(self, cmd, label=False):
        """Show help for a single set subcommand"""
        if label:
            self.msg_nocr("set %s --" % cmd)
        if cmd == 'args':
            self.msg("Set argument list to give program being debugged when it is started")
        elif cmd == 'basename':
            self.msg("Set short filenames (the basename) in debug output")
        elif cmd == 'cmdtrace':
            self.msg("Set to show lines read from the " +
                     "debugger command file")
        elif cmd == 'history':
            self.msg("Generic command for setting command history parameters")
        elif cmd == 'interactive':
            self.msg("Set whether we are interactive")
        elif cmd == 'linetrace':
            self.msg("Set line execution tracing and delay on tracing")
        elif cmd == 'listsize':
            self.msg("Set number of source lines the debugger will list "
                     + "by default")
        elif cmd == 'prompt':
            self.msg("Set debugger's prompt")
        else:
            self.undefined_cmd("help set", cmd)

    def __help_show(self, cmd, label=False):
        """Show help for a single set subcommand"""
        if label:
            self.msg_nocr("show %s --" % cmd)
        if cmd == 'args':
            self.msg("Show argument list to give debugged program on start")
        elif cmd == 'basename':
            self.msg("Show if we are to show short of long filenames")
        elif cmd == 'cmdtrace':
            self.msg("Show if we are to show debugger commands " +
                     "before running")
        elif cmd == 'commands':
            self.msg("Show the history of commands you typed")
        elif cmd == 'history':
            self.msg("Generic command for showing command history parameters")
        elif cmd == 'interactive':
            self.msg("Show whether we are interactive")
        elif cmd == 'linetrace':
            self.msg("Show the line tracing status. Can also add 'delay'")
        elif cmd == 'listsize':
            self.msg("Show number of source lines the debugger will list "
                     + "by default")
        elif cmd == 'prompt':
            self.msg("Show debugger's prompt")
        elif cmd == 'version':
            self.msg("Show what version of this is")
        else:
            self.undefined_cmd("help show", cmd)

    def __info_args(self, arg):
        """Print the arguments of the current function."""
        f = self.curframe
        co = f.f_code
        dict = f.f_locals
        n = co.co_argcount
        if co.co_flags & inspect.CO_VARARGS: n += 1
        if co.co_flags & inspect.CO_VARKEYWORDS: n += 1
        for i in range(n):
            name = co.co_varnames[i]
            self.msg_nocr("%s=" %  name)
            if name in dict: self.msg(dict[name])
            else: self.msg("*** undefined ***")

    def canonic_filename(self, frame):
        return self.canonic(frame.f_code.co_filename)

    def checkline(self, filename, lineno):
        """Check whether specified line seems to be executable.

        Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank
        line or EOF). Warning: testing is not comprehensive.
        """
        line = linecache.getline(filename, lineno)
        if not line:
            self.errmsg('End of file')
            return 0
        line = line.strip()
        # Don't allow setting breakpoint at a blank line
        if (not line or (line[0] == '#') or
             (line[:3] == '"""') or line[:3] == "'''"):
            self.errmsg('Blank or comment')
            return 0
        return lineno

    # To be overridden in derived debuggers
    def defaultFile(self):
        """Produce a reasonable default."""
        filename = self.curframe.f_code.co_filename
        # Consider using is_exec_stmt(). I just don't understand
        # the conditions under which the below test is true.
        if filename == '<string>' and self.mainpyfile:
            filename = self.mainpyfile
        return filename

    def display_enable(self, arg, flag):
        # arg is list of display points
        for i in arg:
            try:
                i = int(i)
                self.display.enable(i, flag)
            except ValueError:
                self.msg('index %r is not a number' % i)
                continue

    def lineinfo(self, identifier):
        failed = (None, None, None)
        # Input is identifier, may be in single quotes
        idstring = identifier.split("'")
        if len(idstring) == 1:
            # not in single quotes
            id = idstring[0].strip()
        elif len(idstring) == 3:
            # quoted
            id = idstring[1].strip()
        else:
            return failed
        if id == '': return failed
        parts = id.split('.')
        # Protection for derived debuggers
        if parts[0] == 'self':
            del parts[0]
            if len(parts) == 0:
                return failed
        # Best first guess at file to look at
        fname = self.defaultFile()
        if len(parts) == 1:
            item = parts[0]
        else:
            # More than one part.
            # First is module, second is method/class
            f = self.lookupmodule(parts[0])
            if f:
                fname = f
            item = parts[1]
        answer = find_function(item, fname)
        return answer or failed

    def filename(self, filename=None):
        if filename is None:
            filename = self.file
        """Return filename or the basename of that depending on the
        self.basename setting"""
        if self.basename:
            return(os.path.basename(filename))
        return filename

    def forget(self):
        self.lineno = None
        self.stack = []
        self.curindex = 0
        self.curframe = None

    def interaction(self, frame, traceback):
        """Possibly goes into loop to read debugger commands."""
        do_loop = self.setup(frame, traceback) != 1
        if do_loop:
            self.print_location()
            self.display.displayAny(self.curframe)
            if not self.noninteractive:
                try:
                    self.cmdloop()
                except KeyboardInterrupt:
                    self.do_quit(None)
        self.currentbp = None    # Can forget it now that we're moving on
        self.forget()
        if not do_loop:
            return 1

    def print_location(self, prompt_prefix=line_prefix):
        """Show where we are. GUI's and front-end interfaces often
        use this to update displays. So it is helpful to make sure
        we give at least some place that's located in a file.      
        """
        i_stack = self.curindex
        while i_stack >= 0:
            frame_lineno = self.stack[i_stack]
            i_stack -= 1
            frame, lineno = frame_lineno
            filename = self.filename(self.canonic_filename(frame))
            self.msg_nocr('(%s:%s):' % (filename, lineno))
            fn_name = frame.f_code.co_name
            if fn_name and fn_name != '?':
                self.msg(" %s" % frame.f_code.co_name)
            else:
                self.msg("")

            # If we are stopped at an "exec" or print the next outer
            # location for that front-ends tracking source execution.
            if not is_exec_stmt(frame):
                break

    def print_stack_entry(self, i_stack):
        frame_lineno = self.stack[len(self.stack)-i_stack-1]
        frame, lineno = frame_lineno
        if frame is self.curframe:
            self.msg_nocr('->')
        else:
            self.msg_nocr('##')
        self.msg("%d %s" %
                 (i_stack, self.format_stack_entry(frame_lineno)))

    def print_stack_trace(self, count=None):
        "Print count entries of the stack trace"
        if count is None:
            n=len(self.stack)
        else:
            n=min(len(self.stack), count)
        try:
            for i in range(n):
                self.print_stack_entry(i)
        except KeyboardInterrupt:
            pass

    def setup(self, frame, traceback=None):
        """Initialization done before entering the debugger-command
        loop. We return 1 if we should NOT enter the debugger-command
        loop."""
        self.forget()
        self.stack, self.curindex = self.get_stack(frame, traceback)
        self.curframe = self.stack[self.curindex][0]
        if self.execRcLines()==1: return 1

    def setup_source(self, arg, showError=False):
        """Set up to read commands from a source file"""
        try:
            rcFile = open(os.path.join(arg))
        except IOError, (errno, strerror):
            if showError:
                self.errmsg("Error opening debugger command file %s: %s"
                            % (arg, strerror))
            pass
        else:
            for line in rcFile.readlines():
                self.rcLines.append(line)
            rcFile.close()

    def show_commands(self, arg):
        """Show the history of commands you typed.
You can supply a command number to start with, or a `+' to start after
the previous command number shown."""
        try:
            import readline
            if self.histfile is not None:
                if arg is None:
                    first=1
                    self.hist_last=readline.get_current_history_length()
                else:
                    if arg == '+':
                        first = self.hist_last+1
                        self.hist_last = min(self.hist_last,
                                             first + self.listsize)
                    else:
                        try: 
                            center = self.get_pos_int(arg,
                                                      cmdname="show commands")
                        except ValueError:
                            return
                        first = max(1, center - (self.listsize/2))
                        self.hist_last = min(self.hist_last,
                                             center + (self.listsize/2))
                i=first
                while i<=self.hist_last:
                    self.msg("%5d  %s" % (i, readline.get_history_item(i)))
                    i += 1
            else:
                self.errmsg("History mechanism turned off.")
        except ImportError:
            self.errmsg("Readline not available.")
            
    def write_history_file(self):
        """Write the command history file -- possibly."""
        if self.hist_save:
            try:
                import readline
                try:
                    readline.write_history_file(self.histfile)
                except IOError:
                    pass
            except ImportError:
                pass

    ###################################################################
    # Command definitions, called by cmdloop()
    # The argument is the remaining string on the command line
    # Return true to exit from the command loop
    ###################################################################

    def do_alias(self, arg):
        """alias [name [command [parameter parameter ...] ]]
Creates an alias called 'name' the executes 'command'.  The command
must *not* be enclosed in quotes.  Replaceable parameters are
indicated by %1, %2, and so on, while %* is replaced by all the
parameters.  If no command is given, the current alias for name
is shown. If no name is given, all aliases are listed.

Aliases may be nested and can contain anything that can be
legally typed at the debugger prompt.  Note!  You *can* override
internal debugger commands with aliases!  Those internal commands
are then hidden until the alias is removed.  Aliasing is recursively
applied to the first word of the command line; all other words
in the line are left alone.

Some useful aliases (especially when placed in the .%src file) are:

#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]

#Print instance variables in self
alias ps pi self
""" % _debugger_name
        args = arg.split()
        if len(args) == 0:
            keys = self.aliases.keys()
            keys.sort()
            for alias in keys:
                self.msg("%s = %s" % (alias, self.aliases[alias]))
            return
        if args[0] in self.aliases and len(args) == 1:
            self.msg("%s = %s" % (args[0], self.aliases[args[0]]))
        else:
            self.aliases[args[0]] = ' '.join(args[1:])

    def do_break(self, arg, temporary = 0):
        """b(reak) {[file:]lineno | function} [, condition]
With a line number argument, set a break there in the current
file.  With a function name, set a break at first executable line
of that function.  Without argument, list all breaks.  If a second
argument is present, it is a string specifying an expression
which must evaluate to true before the breakpoint is honored.

The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that
hasn't been loaded yet).  The file is searched for on sys.path;
the .py suffix may be omitted."""
        cond = None
        funcname = None
        if not arg:
            if self.lineno is None:
                lineno = max(1, inspect.getlineno(self.curframe))
            else:
                lineno = self.lineno + 1
            filename = self.curframe.f_code.co_filename
        else:
            # parse arguments; comma has lowest precedence
            # and cannot occur in filename
            filename = None
            lineno = None
            comma = arg.find(',')
            if comma > 0:
                # parse stuff after comma: "condition"
                cond = arg[comma+1:].lstrip()
                arg = arg[:comma].rstrip()
            # parse stuff before comma: [filename:]lineno | function
            # Make sure it works for "clear C:\foo\bar.py:12"
            colon = arg.rfind(':')
            if colon >= 0:
                filename = arg[:colon].rstrip()
                f = self.lookupmodule(filename)
                if not f:
                    self.errmsg("%s not found from sys.path" % repr(filename))
                    return
                else:
                    filename = f
                arg = arg[colon+1:].lstrip()
                try:
                    lineno = int(arg)
                except ValueError, msg:
                    self.errmsg('Bad lineno: %s', str(arg))
                    return
            else:
                # no colon; can be lineno or function
                (funcname, filename, lineno) = self.__get_brkpt_lineno(arg)
                if lineno is None: return
                
        # FIXME This default setting doesn't match that used in
        # do_clear. Perhaps one is non-optimial.
        if not filename:
            filename = self.defaultFile()

        # Check for reasonable breakpoint
        line = self.checkline(filename, lineno)
        if line:
            # now set the break point
            # Python 2.3.5 takes 5 args rather than 6.
            # There's probably a way in configure to test for the version,
            # but this works too.
            try:
               err = self.set_break(filename, line, temporary, cond, funcname)
            except TypeError:
               err = self.set_break(filename, line, temporary, cond)

            if err: self.errmsg(err)
            else:
                bp = self.get_breaks(filename, line)[-1]
                self.msg("Breakpoint %d set in file %s, line %d."
                         % (bp.number, self.filename(bp.file), bp.line))

    do_b = do_break

    def do_cd(self, arg):
        """Set working directory to DIRECTORY for debugger and program
        being debugged. """
        if not arg:
            self.errmsg("Argument required (new working directory).")
        else:
           os.chdir(arg)

    def do_clear(self, arg):
        """cl(ear) {[file:]linenumber | function}

        Clear breakpoint at specified line or function.  Argument may
        be line number, function name, or '*' and an address.  If line
        number is specified, all breakpoints in that line are cleared.
        If function is specified, breakpoints at beginning of function
        are cleared.  If an address is specified, breakpoints at that
        address are cleared.

        With no argument, clears all breakpoints in the line that the
        selected frame is executing in.

        See also the 'delete' command which clears breakpoints by number.
        """

        if not arg:
            frame, lineno = self.stack[self.curindex]
            filename = self.canonic_filename(self.curframe)

        else:
            if ':' in arg:
                # Make sure it works for "clear C:\foo\bar.py:12"
                i = arg.rfind(':')
                filename = arg[:i]
                arg = arg[i+1:]
                try:
                    lineno = int(arg)
                except:
                    self.errmsg("Invalid line number (%s)" % arg)
                    return
            else:
                (funcname, filename, lineno) = self.__get_brkpt_lineno(arg)
                    
            if lineno is None: return

            # FIXME This default setting doesn't match that used in
            # do_break. Perhaps one is non-optimial.
            if filename is None:
                filename = self.canonic_filename(self.curframe)
                    
        brkpts = self.clear_break(filename, lineno)

        if len(brkpts) > 0:
            if len(brkpts) == 1:
                self.msg("Deleted breakpoint %d" % brkpts[0])
            else:
                self.msg("Deleted breakpoints " +
                         ' '.join(map(lambda b: str(b), brkpts)))
        return

    do_cl = do_clear

    def do_condition(self, arg):
        """condition bpnumber str_condition

        str_condition is a string specifying an expression which must
        evaluate to true before the breakpoint is honored.  If
        str_condition is absent, any existing condition is removed;
        i.e., the breakpoint is made unconditional."""

        args = arg.split(' ', 1)
        try:
            bpnum = self.get_pos_int(args[0].strip(), min=1,
                                     cmdname='condition')
        except ValueError:
            return
        except IndexError:
            self.errmsg("Breakpoint number required.")
        try:
            cond = args[1]
        except:
            cond = None
        try:
            bp = bdb.Breakpoint.bpbynumber[bpnum]
        except IndexError:
            self.errmsg("No breakpoint number %d." % bpnum)
            return
        if bp:
            bp.cond = cond
            if not cond:
                self.msg('Breakpoint %d is now unconditional.' % bpnum)

    # Note: ddd only uses first line of docstring after the command name.
    # That is the part that starts Continue execution...
    # So make sure this is a complete sentence.
    def do_continue(self, arg):
        """c(ont(inue))

        Continue execution; only stop when a breakpoint is encountered."""
        if not self.is_running(): return
        if self.linetrace:
            # linetracing is like stepping, but we just don't stop. If
            # we were to calling set_continue, it  *might* remove all
            # stopping if there were no breakpoints.
            self.step_ignore = -1
            self.set_step()
        else:
            self.set_continue()
        return 1
    do_c = do_cont = do_continue

    def do_debug(self, arg):
        """debug code
        Enter a recursive debugger that steps through the code argument
        (which is an arbitrary expression or statement to be executed
        in the current environment)."""
        sys.settrace(None)
        globals = self.curframe.f_globals
        locals = self.curframe.f_locals
        p = Pdb()
        p.prompt  = "(%s) " % self.prompt.strip()
        self.msg("ENTERING RECURSIVE DEBUGGER")

        # Inherit some values from current environemnt
        p.aliases         = self.aliases
        p.basename        = self.basename
        p.cmdtrace        = self.cmdtrace
        p.gdb_dialect     = self.gdb_dialect
        p.linetrace       = self.linetrace
        p.linetrace_delay = self.linetrace_delay
        p.listsize        = self.listsize
        p.noninteractive  = self.noninteractive
        
        sys.call_tracing(p.run, (arg, globals, locals))
        self.msg("LEAVING RECURSIVE DEBUGGER")
        sys.settrace(self.trace_dispatch)
        self.lastcmd = p.lastcmd
        self.print_location()

    def do_delete(self, arg):
        """delete [bpnumber [bpnumber...]]  - Delete some breakpoints.
        Arguments are breakpoint numbers with spaces in between.  To
        delete all breakpoints, give no argument.  those breakpoints.
        Without argument, clear all breaks (but first ask
        confirmation).
        
        See also the 'clear' command which clears breakpoints by
        line/file number.."""
        if not arg:
            while True and not self.noninteractive:
                try:
                    reply = raw_input('Delete all breakpoints (y or n)? ')
                except EOFError:
                    reply = 'no'
                    reply = reply.strip().lower()
                if reply in ('y', 'yes'):
                    self.clear_all_breaks()
                    break
                elif reply in ('n', 'no'):
                    return
                else:
                    self.msg("Please answer y or n.")

        numberlist = arg.split()
        for arg in numberlist:
            try:
                i = self.get_pos_int(arg, min=1, default=None,
                                     cmdname='delete')
            except ValueError:
                continue

            if not (i < len(bdb.Breakpoint.bpbynumber)):
                self.errmsg('No breakpoint numbered %d.' % i)
                continue
            err = self.clear_bpbynumber(i)
            if err:
                self.errmsg(err)
            else:
                self.msg('Deleted breakpoint %d' % i)

    def do_disable(self, arg):
        """disable [display] bpnumber [bpnumber ...]

        Disables the breakpoints given as a space separated list of bp
        numbers."""

        args = arg.split()
        if len(args) == 0:
            self.errmsg('No breakpoint number given')
            return
        if args[0] == 'display':
            self.display_enable(args[1:], 0)
            return
        for i in args:
            try:
                i = int(i)
            except ValueError:
                self.msg('Breakpoint index %r is not a number' % i)
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                self.msg('No breakpoint numbered %d' % i)
                continue

            bp = bdb.Breakpoint.bpbynumber[i]
            if bp:
                bp.disable()

    def do_disassemble(self, arg):
        """disassemble [arg]
        With no argument disassemble at the current frame location.
        With a numeric argument, disassemble at the frame location at that
        line number. With a class, method, function, code or string argument
        disassemble that."""
        if not arg:
            dis.disassemble(self.curframe.f_code, self.curframe.f_lasti)
        else:
            try:
                i = int(arg)
                dis.disassemble(self.curframe.f_code, i)
            except ValueError:
                try: 
                    obj=self.getval(arg)
                    dis.dis(obj)
                except NameError:
                    pass
        
    def do_display(self, arg):
        """display [format] EXP

        Print value of expression EXP each time the program stops.
        FMT may be used before EXP and may be one of 'c' for char, 
        'x' for hex, 'o' for ocatl, 'f' for float or 's' for string.

        With no argument, display all currently requested auto-display
        expressions.  Use "undisplay" to cancel display requests previously
        made."""

        if not arg:
            # Display anything active
            self.display.displayAny(self.curframe)
        else:
            # Set up a display
            arglist = arg.split()
            if len(arglist) == 2:
               format, variable = arglist
            else:
               format = ""
               variable = arglist[0]
            dp = DisplayNode(self.curframe, variable, format)
            res = dp.checkValid(self.curframe)
            print res
        return
    
    def do_down(self, arg):
        """d(own) [count]

        Move the current frame one level down in the stack trace
        (to a newer frame).

        If using gdb dialect up matches the gdb: 0 is the most recent
        frame.  Otherwise we match Python's stack: 0 is the oldest
        frame.  """

        try:
            count = self.get_int(arg, cmdname="down")
        except ValueError:
            return
        if self.gdb_dialect:
            count = -count
        self.__adjust_frame(pos=-count, absolute_pos=False)
    do_d = do_down

    def do_enable(self, arg):
        """enable [display] bpnumber [bpnumber ...]]

        Enables the breakpoints given as a space separated list of bp
        numbers."""
        args = arg.split()
        if len(args) == 0:
            self.errmsg('No breakpoint number given')
            return

        if args[0] == 'display':
            self.display_enable(args[1:], True)
            return

        for i in args:
            try:
                i = int(i)
            except ValueError:
                self.msg('Breakpoint index %r is not a number' % i)
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                self.errmsg('No breakpoint numbered %d' % i)
                continue

            bp = bdb.Breakpoint.bpbynumber[i]
            if bp:
                bp.enable()

    def do_examine(self, arg):
        """examine expression - Print the type of the expression and
        prettyprint its value.  For functions, methods, classes and
        modules we print out the documentation string if any.

        For functions we also show the argument list."""
        try: 
            obj = self.getval(arg)
        except:
            return
        if inspect.isfunction(obj):
            # For functions we print the fn(args) and doc if it exists
            self.msg("def %s%s:" % 
                     (arg, inspect.formatargspec(inspect.getargspec(obj)[0])))
            doc=inspect.getdoc(obj)
            if doc != None and doc != '': 
                self.msg(doc)
            self.msg(repr(obj))
        elif inspect.ismodule(obj) or inspect.isbuiltin(obj) \
                or inspect.isclass(obj):
            self.msg(repr(obj))
            doc=inspect.getdoc(obj)
            if doc != None and doc != '': 
                self.msg(doc)
        else:
            self.do_whatis(arg)
            self.do_pp(arg)

#    def do_file(self, fname):
#
#        """ Use FILE as program to be debugged.  It is compiled and
#        becomes is the program executed when you use the `run'
#        command.  If FILE cannot be found as specified, your execution
#        directory path ($PATH) is searched for a command of that name.
#        No arg means to have no executable file and no symbols."""
#
#        if fname == "":
#            if self.mainpyfile == "":
#                print 'No exec file now.\nNo symbol file now.'
#                return
#            else:
#                # should confirm this per
#                #Discard symbol table from `/work/.../ddd/cxxtest'? (y or n) n
#                # XXX 
#                # del module
#                sys.path = self.originalpath[:]
#                self.mainpyfile == ""
#        else:
#            path, module = os.path.split(fname)
#            module = module.split('.')[0]
#            sys.path = self.originalpath[:]
#            sys.path.insert(0, path)
#            # XXX how to clean up name space ??
#            if self.moduletodebug:
#                try:
#                    # del self.moduletodebug
#                    self.moduletodebug = ''
#                except:
#                    pass
#            line = "import " + module + '\n'
#            code = compile(line, '<stdin>', 'single')
#            globals = self.curframe.f_globals
#            locals = self.curframe.f_locals
#            exec code in globals, locals
#            # Could print 'Reading symbols from fname...done.' for gdb conformance
#            self.mainpyfile = fname
#            self.moduletodebug = module

    def do_finish(self, arg):
        """finish

        Continue execution until the current function returns."""
        if not self.is_running(): return
        self.set_return(self.curframe)
        if self.linetrace:
            self.step_ignore = -1
            self.stopframe = None
        return 1

    def do_frame(self, arg):
        """frame frame-number
        Move the current frame to the specified frame number. 

        If using gdb dialect up matches the gdb: 0 is the most recent
        frame.  Otherwise we match Python's stack: 0 is the oldest
        frame.

        A negative number indicates position from the other end.
        So 'frame -1' moves when gdb dialect is in effect moves
        to the oldest frame, and 'frame 0' moves to the newest frame."""

        try:
            arg = int(arg)
        except ValueError:
            self.errmsg(("The 'frame' command requires a frame number."+
                         " Got: %s") % arg)
            return

        i_stack = len(self.stack)
        if arg < -i_stack or arg > i_stack-1:
            self.errmsg('Frame number has to be in the range %d to %d' \
                  % (-i_stack, i_stack-1))
        else:
            self.__adjust_frame(pos=arg, absolute_pos=True)

    def do_ignore(self,arg):
        """ignore bpnumber count

        Sets the ignore count for the given breakpoint number.  A
        breakpoint becomes active when the ignore count is zero.  When
        non-zero, the count is decremented each time the breakpoint is
        reached and the breakpoint is not disabled and any associated
        condition evaluates to true."""
        args = arg.split()
        bpnum = int(args[0].strip())
        try:
            count = int(args[1].strip())
        except:
            count = 0
        bp = bdb.Breakpoint.bpbynumber[bpnum]
        if bp:
            bp.ignore = count
            if count > 0:
                reply = 'Will ignore next '
                if count > 1:
                    reply = reply + '%d crossings' % count
                else:
                    reply = reply + '1 crossing'
                self.msg('%s of breakpoint %d.' % (reply, bpnum))
            else:
                self.msg('Will stop next time breakpoint %d is reached.' %
                         bpnum)

    def do_info(self, arg):
        """Generic command for showing things about the program being
        debugged."""
        if not arg:
            self.help_info([])
            return

        arglist = arg.split()
        arg = arglist[0]
        frame=self.curframe
        if "args" == arg:
            self.__info_args(None)
        elif "break" == arg:
            # FIXME: Should split out the "info" part in args
            self.do_L(None)
        elif 'display' == arg:
            if not self.display.displayAll():
                self.msg('There are no auto-display expressions now.')
        elif "globals" == arg:
            self.msg("\n".join(["%s = %s"
                                % (l, pprint.pformat(self.getval(l)))
                                for l in frame.f_globals]))
        elif "line" == arg:
            #info line identifier
            if len(arglist) == 2:
                # lineinfo returns (item, file, lineno) or (None,)
                answer = self.lineinfo(arglist[1])
                if answer[0]:
                    item, file, lineno = answer
                    self.msg('Line %s of "%s" <%s>' %
                             (lineno, file, item))
                return
            #info line
            self.msg('Line %d of \"%s\" at instruction %d' % 
                     (inspect.getlineno(frame),
                      self.filename(self.canonic_filename(frame)),
                     self.curframe.f_lasti))
        elif "locals" == arg:
            self.msg("\n".join(["%s = %s"
                                % (l, pprint.pformat(self.getval(l)))
                                for l in frame.f_locals]))
        elif 'program' == arg:
            if self.is_running():
                self.msg('Program stopped.')
                if self.currentbp:
                    self.msg('It stopped at breakpoint %d.' % self.currentbp)
                elif self.stop_reason == 'call':
                    self.msg('It stopped at a call.')
                elif self.stop_reason == 'exception':
                    self.msg('It stopped as a result of an exception.')
                elif self.stop_reason == 'return':
                    self.msg('It stopped at a return.')
                else:
                    self.msg("It stopped after stepping, next'ing or initial start.")
            return
        elif "source" == arg:
            self.msg('Current Python file is %s' %
                     self.filename(self.canonic_filename(frame)))
        else:
            self.undefined_cmd("info", arg)

    def info_break(self, arg):
        """info break

        Without argument, list info about all breakpoints.  With an
        integer argument, list info on that breakpoint.

        The short command name is L."""
        if self.breaks:  # There's at least one
            self.msg("Num Type          Disp Enb    Where")
            for bp in bdb.Breakpoint.bpbynumber:
                if bp:
                    self.bpprint(bp)
        else:
            self.msg("No breakpoints.")

    do_L = info_break

    def do_jump(self, arg, cmdname='Jump'):
        """j(ump) lineno

        Set the next line that will be executed."""

        if self.curindex + 1 != len(self.stack):
            self.errmsg("You can only jump within the bottom frame")
            return
        try:
            arg = int(arg)
        except ValueError:
            self.errmsg("The 'jump' command requires a line number.")
        else:
            try:
                # Do the jump, fix up our copy of the stack, and display the
                # new position
                self.curframe.f_lineno = arg
                self.stack[self.curindex] = self.stack[self.curindex][0], arg
                self.print_location()
            except ValueError, e:
                self.errmsg('%s failed: %s' % (cmdname, e))

    do_j = do_jump

    def do_list(self, arg):
        """l(ist) [first [,last]]
        List source code for the current file.
        Without arguments, list 11 lines around the current line
        or continue the previous listing.
        With one argument, list 11 lines starting at that line.
        With two arguments, list the given range;
        if the second argument is less than the first, it is a count."""
        self.lastcmd = 'list'
        last = None
        if arg:
            try:
                x = eval(arg, {}, {})
                if type(x) == type(()):
                    first, last = x
                    first = int(first)
                    last = int(last)
                    if last < first:
                        # Assume it's a count
                        last = first + last
                else:
                    first = max(1, int(x) - (self.listsize/2))
            except:
                self.errmsg('Error in argument: %s' % repr(arg))
                return
        elif self.lineno is None or not self.running:
            first = max(1, inspect.getlineno(self.curframe) - 5)
        else:
            first = self.lineno + 1
        if last is None:
            last = first + self.listsize
        filename = self.curframe.f_code.co_filename
        breaklist = self.get_file_breaks(filename)
        try:
            for lineno in range(first, last+1):
                line = linecache.getline(filename, lineno)
                if not line:
                    self.msg('[EOF]')
                    break
                else:
                    s = repr(lineno).rjust(3)
                    if len(s) < 4: s = s + ' '
                    if lineno in breaklist: s = s + 'B'
                    else: s = s + ' '
                    if lineno == inspect.getlineno(self.curframe):
                        s = s + '->'
                    self.msg_nocr(s + '\t' + line)
                    self.lineno = lineno
        except KeyboardInterrupt:
            pass
    do_l = do_list

    def do_next(self, arg):
        """n(ext) [count]
Continue execution until the next line in the current function is reached or it returns.

With an integer argument, perform that many times."""
        if not self.is_running(): return
        try:
            # 0 means stop now or step 1, so we subtract 1.
            self.step_ignore = self.get_pos_int(arg, default=1,
                                                cmdname='next') - 1
        except ValueError:
            return

        self.set_next(self.curframe)
        return 1
    do_n = do_next

    def do_p(self, arg):
        """p expression
        Print the value of the expression."""
        try:
            self.msg(repr(self.getval(arg)))
        except:
            pass

    def do_pp(self, arg):
        """pp expression
        Pretty-print the value of the expression."""
        try:
            self.msg(pprint.pformat(self.getval(arg)))
        except:
            pass

    def do_pwd(self, arg):
        "Print working directory."
        self.msg('Working directory ' + os.getcwd() + '.')

    def do_quit(self, arg):
        """q(uit) or exit - Quit the debugger.  The program being
        executed is aborted. For now, kill is a synonym for quit."""
        self._user_requested_quit = True
        self.running              = False
        self.set_quit()
        return 1

    do_kill = do_q = do_quit

    def do_restart(self, arg):
        """restart - Restart debugger and program via an exec
        call. All state is lost, and new copy of the debugger is used."""

        self.msg("Re exec'ing\n\t%s" % self._sys_argv)
        os.execvp(self._sys_argv[0], self._sys_argv)
        

    def do_return(self, arg):
        """Make selected stack frame return to its caller. Control
        remains in the debugger, but when you continue execution will
        resume at the return statement found inside the subroutine or
        method.  At present we are only able to perform this if we are
        in a subroutine that has a 'return' statement in it."""
        if not self.is_running(): return
        frame = self.curframe

        if '?' == frame.f_code.co_name and not '__args__' in frame.f_locals:
            self.errmsg("I don't see that we are in a subroutine.")
            return

        while True and not self.noninteractive:
            try:
                # reply = raw_input('Make %s return now? (y or n) ')
                reply = raw_input('Return now? (y or n) ')
            except EOFError:
                reply = 'no'
                reply = reply.strip().lower()
            if reply in ('y', 'yes'):
                break
            elif reply in ('n', 'no'):
                return
            else:
                self.msg("Please answer y or n.")

        co = frame.f_code
        code = co.co_code
        labels = dis.findlabels(code)
        linestarts = dict(dis.findlinestarts(co))

        i=frame.f_lasti
        last_stmt = i
        last_line = inspect.getlineno(frame)
        # print "++i: %d, len(code): %d" % (i, len(code))
        while i < len(code):
            i += 1
            if i in labels:
                # print "++last_stmt %d" % i
                last_stmt = i
                last_line = None
            if i in linestarts and i > 0:
                # print "++last_line %d" % linestarts[i]
                last_line = linestarts[i]
            if 'RETURN_VALUE' == op_at_frame(frame, i):
                break

        if i == len(self.stack) or last_line is None:
            self.msg("Sorry; a return statement was not found.")
            return

        # print "++i: %d, last_stmt %d, line: %d " % (i, last_stmt, last_line)
        self.do_jump(last_line, "Return")

    def do_retval(self, arg):
        """retval - Show the value that is to be returned from a
function.  This command is useful after a 'finish' command or stepping
just after a 'return' statement. To change the value, make an
assignment to the variable __return__."""
        if '__return__' in self.curframe.f_locals:
            self.msg(self.curframe.f_locals['__return__'])
        else:
            self.errmg('Not yet returned!')
    do_rv = do_retval

    def do_run(self, arg):
        """run [args...]

        Run/Restart the debugged Python program. If a string is
        supplied that becomes the new command arguments.  History,
        breakpoints, actions and debugger options are preserved."""
        if arg:
            argv_start = self._program_sys_argv[0:1]
            self._program_sys_argv = arg.split(" ")
            self._program_sys_argv[:0] = argv_start

        raise Restart

    do_R = do_run

    def do_set(self, arg):
        """See help_set"""
        args = arg.split()
        if len(args) < 2:
            self.errmsg("Expecting at least 2 arguments. Got %d" % len(args))
            return
        if args[0] == 'args':
            argv_start = self._program_sys_argv[0:1]
            if arg:
                self._program_sys_argv = arg.split(" ")[1:]
            else:
                self._program_sys_argv = []
            self._program_sys_argv[:0] = argv_start

        elif args[0] == 'basename':
            try:
                self.basename = self.get_onoff(args[1])
            except ValueError:
                pass

        elif args[0] == 'cmdtrace':
            try:
                self.cmdtrace = self.get_onoff(args[1])
            except ValueError:
                pass
        elif args[0] == 'history':
            if args[1] == 'filename':
                if len(args) < 3:
                    self.errmsg("Argument required (filename to set it to.")
                    return
                self.histfile = args[2]
            elif args[1] == 'save':
                self.hist_save = ( (len(args) >=3 and self.get_onoff(args[2]))
                                   or True )
            elif args[1] == 'size':
                try:
                    size = self.get_int(args[2], cmdname="set history size")
                    readline.set_history_length(size)
                except ValueError:
                    return
            else:
                self.undefined_cmd("set history", args[0])
                
        elif args[0] == 'interactive':
            self.noninteractive = not self.get_onoff(args[1])
        elif args[0] == 'linetrace':
            if args[1]=='delay':
                try:
                    delay = float(args[2])
                    self.linetrace_delay = delay
                except IndexError:
                    self.errmsg("Need a 3rd floating-point number")
                except ValueError:
                    self.errmsg(("3rd argument %s is not a floating-point "
                                 + "number") % str(args[2]) )
            else:
                try:
                    self.linetrace = self.get_onoff(args[1])
                except ValueError:
                    pass
            
        elif args[0] == 'listsize':
            try:
                self.listsize = self.get_int(args[1])
            except ValueError:
                pass
        elif args[0] == 'prompt':
            # Use the original prompt so we keep spaces and punctuation
            # just skip over the work prompt.
            re_prompt = re.compile(r'\s*prompt\s(.*)$')
            mo = re_prompt.search(arg)
            if mo:
                self.prompt = mo.group(1)
            else:
                self.errmsg("Something went wrong trying to find the prompt")
        else:
            self.errmsg("unknown set subcommand %s" %  args[0])

    def do_shell(self, arg):
        """Execute the rest of the line as a shell command."""
        os.system(arg)

    def do_show(self, arg):
        """Generic command for showing things about the debugger."""
        if not arg:
            for subcommand in ['args',      'basename', 'cmdtrace', 
                               'linetrace', 'linetrace delay',
                               'listsize', 'prompt',
                               'version']:
                self.msg_nocr("%s: " % subcommand)
                self.do_show(subcommand)
            return

        args = arg.split()
        if args[0] == 'args':
            self.msg("Argument list to give program being debugged " +
                      "when it is started is ")
            self.msg('"%s".' % " ".join(self._program_sys_argv[1:]))
        elif args[0] == 'basename':
            self.msg("basename is %s." % show_onoff(self.basename))
        elif args[0] == 'cmdtrace':
            self.msg("cmdtrace is %s." % show_onoff(self.cmdtrace))
        elif args[0] == 'commands':
            self.show_commands(len(args) > 1 and args[1] or None)
        elif args[0] == 'history':
            try:
                import readline
                self.msg(
"""filename:  The filename in which to record the command history is
"%s".""" % self.histfile)
                self.msg("save:  Saving of the history record on exit is %s"
                         % show_onoff(self.hist_save))
                self.msg("size:  The size of the command history is %d"
                         % readline.get_history_length())
            except ImportError:
                pass
        elif args[0] == 'interactive':
            self.msg("interactive is %s." %
                     show_onoff(not self.noninteractive))
        elif arg == 'linetrace':
            self.msg("line tracing is %s." % show_onoff(self.linetrace))
        elif _re_linetrace_delay.match(arg):
            self.msg("line trace delay is %s. (In seconds)"
                     % self.linetrace_delay)
        elif args[0] == 'listsize':
            self.msg("Number of source lines %s will list by default is %d." \
                  % (_debugger_name, self.listsize))
        elif args[0] == 'prompt':
            self.msg("""%s's prompt is "%s".""" %
                     (_debugger_name, self.prompt))
        elif args[0] == 'version':
            self.msg("""%s version %s.""" %
                     (_debugger_name, "@PACKAGE_VERSION@"))
        else:
            self.undefined_cmd('show', args[0])

    def do_source(self, arg):
        """source FILE
        Read commands from a file named FILE.
        Note that the file file '.%pydbrc' is read automatically
        in this way when pydb is started.

        An error in any command terminates execution of the command
        file and control is returned to the console."""
        self.setup_source(os.path.expanduser(arg), True);
        rc = self.execRcLines() 
        if rc == 1:  return rc

    def do_step(self, arg):
        """s(tep) [count]
Execute the current line, stop at the first possible occasion
(either in a function that is called or in the current function).

With an integer argument, step that many times."""
        if not self.is_running(): return
        try:
            # 0 means stop now or step 1, so we subtract 1.
            self.step_ignore = self.get_pos_int(arg, default=1,
                                                cmdname='step') - 1
        except ValueError:
            return

        self.set_step()
        return 1
    do_s = do_step

    def do_tbreak(self, arg):
        """tbreak  [ ([filename:]lineno | function) [, condition] ]
        Set a temporary breakpoint. Arguments are like the "break" command.
        Like "break" except the breakoint is only temporary, 
        so it will be deleted when hit."""
        self.do_break(arg, 1)

    def do_unalias(self, arg):
        """unalias name
Deletes the specified alias."""
        args = arg.split()
        if len(args) == 0: return
        if args[0] in self.aliases:
            del self.aliases[args[0]]

    # Print a traceback starting at the top stack frame.
    # The most recently entered frame is printed last;
    # this is different from dbx and gdb, but consistent with
    # the Python interpreter's stack trace.
    # It is also consistent with the up/down commands (which are
    # compatible with dbx and gdb: up moves towards 'main()'
    # and down moves towards the most recent stack frame).

    def do_undisplay(self, arg):
        """Cancel some expressions to be displayed when program stops.
        Arguments are the code numbers of the expressions to stop displaying.
        No argument means cancel all automatic-display expressions.
        "delete display" has the same effect as this command.
        Do "info display" to see current list of code numbers."""

        if arg:
            args = arg.split()
            for i in args:
                try:
                    i = int(i)
                    self.display.deleteOne(i)
                except ValueError:
                    self.errmsg('index %r is not a number' % i)
        else:
            self.display.deleteAll()

    def do_up(self, arg):
        """u(p) [count]
        Move the current frame one level up in the stack trace
        (to an older frame).
        
        If using gdb dialect up matches the gdb: 0 is the most recent
        frame.  Otherwise we match Python's stack: 0 is the oldest
        frame.  """

        try:
            count = self.get_int(arg, cmdname="up")
        except ValueError:
            return
        if self.gdb_dialect:
            count = -count
        self.__adjust_frame(pos=count, absolute_pos=False)
    do_u = do_up

    def do_whatis(self, arg):
        """whatis arg
Prints the type of the argument which can be a Python expression."""
        try:
            value = eval(arg, self.curframe.f_globals,
                         self.curframe.f_locals)
        except:
            t, v = sys.exc_info()[:2]
            if type(t) == types.StringType:
                exc_type_name = t
            else: exc_type_name = t.__name__
            if exc_type_name == 'NameError':
                self.errmsg("Name Error: %s" % arg)
            else:
                self.errmsg("%s: %s" % (exc_type_name, repr(v)))
            return
        if inspect.isfunction(value):
            self.msg('function %s%s' %
                     (value.func_code.co_name,
                       inspect.formatargspec(inspect.getargspec(value))))
            return
        # None of the above...
        self.msg(type(value))

    def do_where(self, arg):
        """where [count]

        Print a stack trace, with the most recent frame at the top.
        With a positive number, print at most many entries.
        An arrow indicates the 'current frame', which determines the
        context of most commands.  'bt' and 'T' are short command
        names for this."""

        try:
            count = self.get_pos_int(arg, default=None, cmdname="where")
        except ValueError:
            return

        self.print_stack_trace(count)

    do_T = do_bt = do_where

    def do_EOF(self, arg):
        """EOF
Handles the receipt of EOF as a command."""
        self.msg("")
        self._user_requested_quit = True
        self.set_quit()
        return 1

    #########################################################
    # Help methods (derived from pydb.doc or vice versa)
    #########################################################

    for fn in ('EOF',     'L',         'alias',       'break',
               'cd',      'clear',     'condition',   'continue',
               'debug',   'disable',   'delete'   ,   'disassemble',
               'display', 'down',      'enable',      'examine',
               'finish',  'frame',     'help',
               'ignore',  'info',      'jump',        'list',
               'next',    'p',         'pp',          'pwd',    'quit',
               'restart', 'retval',    'run',
               'set',     'show',      'shell',       'source', 'step', 
               'tbreak',  'unalias',   'undisplay',   'up',
               'whatis',  'where'):
        exec 'def help_%s(self, *arg): self.msg(getattr(self.do_%s, "__doc__"))' \
             % (fn, fn)

    # Is this the right way to do this? 
    help_h = help_help
    help_R = help_run
    help_bt = help_T = help_where

    def help_exec(self, *arg):
        self.msg("""(!) statement
        Execute the (one-line) statement in the context of
        the current stack frame.
        The exclamation point can be omitted unless the first word
        of the statement resembles a debugger command.
        To assign to a global variable you must always prefix the
        command with a 'global' command, e.g.:
        %sglobal list_options; list_options = ['-l']
        %s""" % (self.prompt, self.prompt))

    # Note: format of help is compatible with ddd.
    def help_info(self, *args):
        """Generic command for showing things about the program being debugged."""
        subcmds=("args", "break", "display", "globals", "line",
                 "locals", "program", "source")
        self.subcommand_help('info', getattr(self, 'help_info').__doc__,
                             subcmds, self.__help_info, args[0])

    def help_pydb(self, *arg):
        help()

    # Note: format of help is compatible with ddd.
    def help_set(self, *args):
        """This command modifies parts of the debugger environment.
You can see these environment settings with the 'show' command."""
        subcmds=("args", "basename", "cmdtrace", "history",
                 "interactive",
                 "linetrace", "listsize", "prompt")
        self.subcommand_help('set', getattr(self, 'help_set').__doc__,
                             subcmds, self.__help_set, args[0])

    # Note: format of help is compatible with ddd.
    def help_show(self, *args):
        """Generic command for showing things about the debugger."""
        subcmds=("args",      "basename",   "cmdtrace",  "commands",
                 "history",  "interactive", "linetrace", "listsize",
                 "prompt", "version")
        self.subcommand_help('show', getattr(self, 'help_show').__doc__,
                             subcmds, self.__help_show, args[0])

    ####### End of help section ########
        
    def _runscript(self, filename):
        # When bdb sets tracing, a number of call and line events happens
        # BEFORE debugger even reaches user's code (and the exact sequence of
        # events depends on python version). So we take special measures to
        # avoid stopping before we reach the main script (see user_line and
        # user_call for details).
        self._wait_for_mainpyfile = True
        self.mainpyfile = self.canonic(filename)

        # Start with fresh empty copy of globals and locals and tell the script
        # that it's being run as __main__ to avoid scripts being able to access
        # the pydb.py namespace.
        globals_ = {"__name__" : "__main__",
                    "__file__" : self.mainpyfile
                    }
        locals_ = globals_


        statement = 'execfile( "%s")' % filename
        self.running = True
        self.run(statement, globals=globals_, locals=locals_)

#########################################################
# Alternative top-level calls
#########################################################

def run(statement, globals=None, locals=None):
    """Execute the statement (given as a string) under debugger
    control. The debugger prompt appears before any code is executed;
    you can set breakpoints and type 'continue', or you can step
    through the statement using 'step' or 'next'

    The optional globals and locals arguments specify the environment
    in which the code is executed; by default the dictionary of the
    module __main__ is used."""
    
    Pdb().run(statement, globals, locals)

def runeval(expression, globals=None, locals=None):
    """Evaluate the expression (given as a string) under debugger
    control.  When runeval() returns, it returns the value of the
    expression.  Otherwise this function is similar to run()."""

    return Pdb().runeval(expression, globals, locals)

def runctx(statement, globals, locals):
    # B/W compatibility
    run(statement, globals, locals)

def runcall(*args, **kwds):
    """ Call the function (a function or method object, not a string)
    with the given arguments.  When runcall() returns, it returns
    whatever the function call returned.  The debugger prompt appears
    as soon as the function is entered."""

    return Pdb().runcall(*args, **kwds)

def set_trace(cmdfile=None):
    """Enter the debugger at the calling stack frame.  This is useful to
    hard-code a breakpoint at a given point in a program, even if the code
    is not otherwise being debugged (e.g., when an assertion fails).
    Leaving this the debugger terminates the program.
    """
    global _pydb_trace
    try:
        if not isinstance(_pydb_trace, Pdb):
            print "Your program should not use _pydb_trace"
            return
    except NameError:
        _pydb_trace = Pdb()
        _pydb_trace.reset()
        _pydb_trace._program_sys_argv = list(sys.argv)
        _pydb_trace._sys_argv = list(_pydb_trace._program_sys_argv)
        _pydb_trace._sys_argv[:0] = [_debugger_name]
    except:
        print "Unknown error"
        return
    # We don't support "run" so we'll make "run" and "R" be "restart"
    _pydb_trace.do_R = _pydb_trace.do_run = _pydb_trace.do_restart
    _pydb_trace.curframe=inspect.currentframe()
    _pydb_trace.running = True

    if cmdfile is not None: _pydb_trace.do_source(cmdfile)

    # There can be no other commands after the following one:
    _pydb_trace.set_trace(_pydb_trace.curframe)

# Post-Mortem interface

def post_mortem(t, opts=None, cmdfile=None):
    """Enter debugger read loop after your program has crashed.
    Opts is a dictionary of debugger variables you want set;
    the key is the variable name and the value is the value to give
    the variable in the pydb instance."""
    p = Pdb()
    p.reset()
    p.running = False
    re_bogus_file = re.compile("^<.+>$")

    # t has least-recent traceback entry first. We want the most-recent
    # entry. Also we'll pick out a mainpyfile name if it hasn't previously
    # been set.
    while t.tb_next is not None:
        filename = t.tb_frame.f_code.co_filename
        if 0 == len(p.mainpyfile) and not re_bogus_file.match(filename):
            p.mainpyfile = filename
        t = t.tb_next
    p.curframe = t.tb_frame

    # We put processing opts after the above traceback loop so we will
    # smash p.mainpyfile if it is given as an option.
    if opts is not None:
        for item in opts.items(): exec "p.%s=%s" % item

    if 0 == len(p._program_sys_argv):
        # Fake program (run command) args since we weren't called with any
        p._program_sys_argv = list(sys.argv[1:])
        p._program_sys_argv[:0] = [p.mainpyfile]

    if 0 == len(p._sys_argv):
        # Fake script invocation (restart) args since we don don't have any
        p._sys_argv = list(p._program_sys_argv)
        p._sys_argv[:0] = [_debugger_name]

    if cmdfile is not None:
        p.do_source(cmdfile)
        
    try:
        p.interaction(t.tb_frame, t)
    except Restart:
        while True:
            sys.argv = list(p._program_sys_argv)
            p.msg("Restarting %s with arguments:\n\t%s"
                  % (p.filename(p.mainpyfile),
                     " ".join(p._program_sys_argv[1:])))
            try:
                p._runscript(p.mainpyfile)
                if p._user_requested_quit:
                    break
                if p.noninteractive: break
            except Restart:
                pass

def pm(opts=None, cmdfile=None):
    """Set up post-mortem debugging using the last traceback.
    Opts is a dictionary of debugger variables you want set;
    the key is the variable name and the value is the value to give
    the variable in the pydb instance."""
    try:
        if not inspect.istraceback(sys.last_traceback):
            print "*** sys.last_traceback is not a traceback?!"
            return
    except AttributeError:
        print "*** Can't find exception to run a post-mortem over."
        return
    post_mortem(sys.last_traceback, opts, cmdfile)


TESTCMD = 'import x; x.main()'

def test():
    run(TESTCMD)

# print help
def help():
    doc_file='%s.doc' % _debugger_name
    for dirname in sys.path:
        fullname = os.path.join(dirname, _debugger_name, doc_file)
        if os.path.exists(fullname):
            sts = os.system('${PAGER-more} '+fullname)
            if sts: self.errmsg('Pager exit status: %s' % str(sts))
            break
    else:
        print ("Sorry, can't find the help file '%s' along the "
                  + "Python search path") % doc_file

#########################################################
# Main program
#########################################################

def main():
    """Routine which gets run if we were invoked directly"""

    pydb = Pdb()
    opts = process_options(pydb, _debugger_name, program)

    # process_options has munged sys.argv to remove any options that
    # options that belong to this debugger. The original options to
    # invoke the debugger and script are in global sys_argv

    if len(sys.argv) == 0:
        print 'Error: you need to give a script name to debug'
        sys.exit(1)

    # Save the DEBUGGED programs arguments. This is in case
    # the debugged script munges these, we have a good copy to use
    # for restart
    pydb._program_sys_argv = list(sys.argv)

    mainpyfile = pydb._program_sys_argv[0] # Get script filename. 
    if not os.path.exists(mainpyfile):
        print 'Error:', mainpyfile, 'does not exist'
        sys.exit(1)

    # Replace pydb's dir with script's dir in front of module search path.
    sys.path[0] = os.path.dirname(mainpyfile)

    while True:

        # Run the debugged script over and over again until we get it
        # right.

        try:
            pydb._runscript(mainpyfile)
            if pydb._user_requested_quit:
                break
            if pydb.noninteractive: break
            pydb.msg("The program finished and will be restarted")
        except Restart:
            sys.argv = list(pydb._program_sys_argv)
            pydb.msg("Restarting %s with arguments:\n\t%s"
                     % (pydb.filename(mainpyfile),
                        " ".join(pydb._program_sys_argv[1:])))
        except SystemExit:
            # In most cases SystemExit does not warrant a post-mortem session.
            pydb.msg("The program exited via sys.exit(). Exit status: %s" %
                     str(sys.exc_info()[1]))
            pydb.running = False;
            if pydb.noninteractive: break
        except:
            traceback.print_exc()
            if pydb.noninteractive:
                pydb.errmsg("Uncaught exception.")
                break
            pydb.errmsg("Uncaught exception. Entering post mortem debugging")
            pydb.errmsg( "Running 'cont' or 'step' will restart the program")
            pydb.running = False;
            t = sys.exc_info()[2]
            while t.tb_next is not None:
                t = t.tb_next
            try:
                pydb.interaction(t.tb_frame,t)
            except Restart:
                sys.argv = list(pydb._program_sys_argv)
                pydb.msg("Restarting %s with arguments:\n\t%s"
                         % (pydb.filename(mainpyfile),
                            " ".join(pydb._program_sys_argv[1:])))
            else:
                pydb.msg("Post mortem debugger finished.")
                pydb.msg(mainpyfile + " will be restarted")
        pydb.step_ignore = 0

init()

# When invoked as main program, invoke the debugger on a script
if __name__=='__main__':
    main()

#
# Local variables:
#  mode: Python
# End:
