"""$Id: gdb.py.in,v 1.39 2006/07/16 04:57:19 rockyb Exp $
Handles gdb-like command processing.
(See also @PACKAGE_NAME@.doc for documentation.)"""

_debugger_name = '@PACKAGE_NAME@'

# The name of the debugger we are currently going by.
_version = '@PACKAGE_VERSION@'

import atexit, dis, inspect, linecache, os, pprint
import bdb, re, sys, traceback, types

import pydbcmd, pydbbdb
from pydbdisp import Display, DisplayNode
from fns import *

from pydbcmd import Cmd
from pydbbdb import Bdb

class Restart(Exception):
    """Causes a debugger to be restarted for the debugged Python program."""
    pass

class Gdb(Bdb, Cmd):
    """A debugger class for Python that resembles the gdb (GNU debugger)
    command set."""
    
    def __init__(self, completekey='tab', stdin=None, stdout=None):
        pydbbdb.Bdb.__init__(self)
        pydbcmd.Cmd.__init__(self, completekey, stdin, stdout)

        self._program_sys_argv    = []   # sys.argv after options are stripped
        self._re_linetrace_delay  = re.compile(r'\s*linetrace\s*')
        self._wait_for_mainpyfile = False
        self._set_cmds =  ['args',        'basename', 'cmdtrace', 'history',
                           'interactive', 'linetrace',
                           'listsize',    'logging',  'prompt']
        self._show_cmds = ['args',        'basename', 'cmdtrace', 'commands',
                           'history',
                           'interactive', 'linetrace',
                           'listsize',  'logging',  'prompt', 'version']
        self._info_cmds = ['args',      'break',    'display', 
                           'globals',   'line',     'locals',
                           'program',   'source']

        self.basename        = False
        self.currentbp       = None   # for "info program"
        self.display         = Display()
        self.gdb_dialect     = True   # Controls how stack is shown
        self.linetrace       = False
        self.linetrace_delay = 0
        self.listsize        = 10

        # main_dirname is the directory where the script resides;
        # "import" statments are relative to this location.

        self.main_dirname    = os.curdir
        self.mainpyfile      = ''
        self.maxargstrsize   = 30     # max length to show of parameter string 
        self.moduletodebug   = ""
        self.noninteractive  = False
        self.originalpath    = sys.path[:]
        self.running         = False
        self.search_path     = '$cdir:$cwd'  # source name search path
        self.stop_reason     = None   # Why are we in the debugger?
        self._sys_argv       = []     # exec sys.argv, e.g. may include pydb
        self.set_history_length   = None


        # associates a command list to breakpoint numbers
        self.commands = {}

        # for each bp num, tells if the prompt must be disp. after
        # execing the cmd list
        self.commands_doprompt = {} 

        # for each bp num, tells if the stack trace must be disp. after
        # execing the cmd list
        self.commands_silent = {} 

        # True while in the process of defining a command list
        self.commands_defining = False

        # The breakpoint number for which we are defining a list        
        self.commands_bnum = None # 

        # list of all the commands making the program
        # resume execution.

        self.commands_resuming = ['do_continue', 'do_jump',  'do_next',
                                  'do_quit',     'do_return',
                                  'do_step']

        # Try to load readline if it exists
        try:
            import @READLINE@
            self.hist_last = 0
            self.hist_save = False
            self.set_history_length = readline.set_history_length
            self.set_history_length(256)
            # Read history file and set up to write history file when we
            # exit. 
            global _debugger_name
            self.histfile = os.path.join(os.environ["HOME"],
                                         ".%shist" % _debugger_name)
            try:
                readline.read_history_file(self.histfile)
            except IOError:
                pass
            atexit.register(self.write_history_file)
            self.do_complete = self.__do_complete

        except ImportError:
            self.histfile = None

    def __adjust_frame(self, pos, absolute_pos):
        """Adjust stack frame by pos positions. If absolute_pos then
        pos is an absolute number. Otherwise it is a relative number.

        If self.gdb_dialect is True, the 0 position is the newest
        entry and doesn't match Python's indexing. Otherwise it does.

        A negative number indexes from the other end."""
        if not self.curframe:
            self.msg("No stack.")
            return
        
        # Below we remove any negativity. At the end, pos will be
        # the new value of self.curindex.
        if absolute_pos:
            if self.gdb_dialect:
                if pos >= 0:
                    pos = len(self.stack)-pos-1
                else:
                    pos -= len(self.stack)
            elif pos < 0:
                pos = len(self.stack)+pos
        else:
            pos += self.curindex

        if pos < 0:
            self.errmsg("Adjusting would be put us beyond the oldest frame")
            return
        elif pos >= len(self.stack):
            self.errmsg("Adjusting would be put us beyond the newest frame")
            return

        self.curindex = pos
        self.curframe = self.stack[self.curindex][0]
        self.print_location()
        self.lineno = None

    def __complete_subcommand(self, prefix, subcmd, text):
        """Print a list of completions for subcmd that start with text.
           We get the list of completions from self._*subcmd*_cmds.
           If no completion we return the empty list.
           """
        matches = []
        try:
            list = getattr(self, "_%s_cmds" % subcmd)
            for word in list:
                if word.startswith(text):
                    matches.append("%s %s" % (subcmd, word))
        except AttributeError:
            pass
        return matches

    def __do_complete(self, arg):
        """Print a list of command names that can start with the
        supplied command prefix. If there is no completion nothing
        is printed."""
        if not arg:
            cmd_prefix=''
            args=[]
        else:
            args = arg.split()
            cmd_prefix=args[0]
        if len(args) > 1:
            if args[0] in pydbcmd.Cmd.complete(self, cmd_prefix, 0):
                text = self.__complete_subcommand(args, args[0], args[1])
                for complete in text:  self.msg(complete)
            return

        seen = {};
        i=0
        text=pydbcmd.Cmd.complete(self, cmd_prefix, i)
        while True:
            if text is None: break
            if text not in seen.keys():
                self.msg(text)
                seen[text]=True
            i += 1
            text=pydbcmd.Cmd.complete(self, cmd_prefix, i)

    def __get_brkpt_lineno(self, arg):
        """__get_brkpt_lineno(self,arg)->(filename, file, lineno)

        See if arg is a line number or a function name.  Return what
        we've found. None can be returned as a value in the triple."""
        funcname, filename = (None, None)
        try:
            # First try as an integer
            lineno = int(arg)
            filename = self.curframe.f_code.co_filename
        except ValueError:
            try:
                func = eval(arg, self.curframe.f_globals,
                            self.curframe.f_locals)
            except:
                func = arg
            try:
                if hasattr(func, 'im_func'):
                    func = func.im_func
                code = func.func_code
                #use co_name to identify the bkpt (function names
                #could be aliased, but co_name is invariant)
                funcname = code.co_name
                lineno = code.co_firstlineno
                filename = code.co_filename
            except:
                # last thing to try
                (ok, filename, ln) = self.lineinfo(arg)
                if not ok:
                    self.errmsg(('The specified object %s is not'
                                 +' a function, or not found'
                                 +' along sys.path or no line given.')
                                % str(repr(arg)))
                    return (None, None, None)
                funcname = ok # ok contains a function name
                lineno = int(ln)
        return (funcname, filename, lineno)

    def __help_show(self, cmd, label=False):
        """Show help for a single set subcommand"""
        if label:
            self.msg_nocr("show %s --" % cmd)
        if 'args'.startswith(cmd):
            self.msg("Show argument list to give debugged program on start")
        elif 'basename'.startswith(cmd):
            self.msg("Show if we are to show short of long filenames")
        elif 'cmdtrace'.startswith(cmd) and len(cmd) > 1:
            self.msg("Show if we are to show debugger commands " +
                     "before running")
        elif 'commands'.startswith(cmd) and len(cmd) > 1:
            self.msg("Show the history of commands you typed")
        elif 'history'.startswith(cmd):
            self.msg("Generic command for showing command history parameters")
        elif 'interactive'.startswith(cmd):
            self.msg("Show whether we are interactive")
        elif 'linetrace'.startswith(cmd):
            self.msg("Show the line tracing status. Can also add 'delay'")
        elif 'listsize'.startswith(cmd):
            self.msg("Show number of source lines the debugger will list "
                     + "by default")
        elif 'logging'.startswith(cmd):
            self.msg("Show logging options")
        elif 'prompt'.startswith(cmd):
            self.msg("Show debugger's prompt")
        elif 'version'.startswith(cmd):
            self.msg("Show what version of the debugger this is")
        else:
            self.undefined_cmd("help show", cmd)

    def __info_args(self, arg):
        """Print the arguments of the current function."""
        f = self.curframe
        co = f.f_code
        dict = f.f_locals
        n = co.co_argcount
        if co.co_flags & inspect.CO_VARARGS: n += 1
        if co.co_flags & inspect.CO_VARKEYWORDS: n += 1
        for i in range(n):
            name = co.co_varnames[i]
            self.msg_nocr("%s=" %  name)
            if name in dict: self.msg(dict[name])
            else: self.msg("*** undefined ***")

    def __parse_filepos(self, arg):
        """__parse_filepos(self,arg)->(fn, filename, lineno)
        
        Parse arg as [filename:]lineno | function
        Make sure it works for C:\foo\bar.py:12
        """
        colon = arg.rfind(':')
        if colon >= 0:
            filename = arg[:colon].rstrip()
            f = self.lookupmodule(filename)
            if not f:
                self.errmsg("%s not found from sys.path" %
                            self._saferepr(filename))
                return (None, None, None)
            else:
                filename = f
                arg = arg[colon+1:].lstrip()
            try:
                lineno = int(arg)
            except ValueError, msg:
                self.errmsg('Bad lineno: %s', str(arg))
                return (None, filename, None)
            return (None, filename, lineno)
        else:
            # no colon; can be lineno or function
            return self.__get_brkpt_lineno(arg)

    # To be overridden in derived debuggers
    def defaultFile(self):
        """Produce a reasonable default."""
        filename = self.curframe.f_code.co_filename
        # Consider using is_exec_stmt(). I just don't understand
        # the conditions under which the below test is true.
        if filename == '<string>' and self.mainpyfile:
            filename = self.mainpyfile
        return filename

    def display_enable(self, arg, flag):
        # arg is list of display points
        for i in arg:
            try:
                i = int(i)
                self.display.enable(i, flag)
            except ValueError:
                self.msg('index %r is not a number' % i)
                continue

    def info_helper(self, cmd, label=False):
        """Show help for a single 'info' subcommand"""
        if label:
            self.msg_nocr("info %s --" % cmd)
        if 'args'.startswith(cmd):
            self.msg("Argument variables of current stack frame")
        elif 'display'.startswith(cmd):
            self.msg("Expressions to display when program stops, " +
                     "with code numbers.")
        elif 'break'.startswith(cmd):
            self.msg("Status of user-settable breakpoints")
        elif 'globals'.startswith(cmd):
            self.msg("Global variables of current stack frame")
        elif 'line'.startswith(cmd) and len(cmd) > 1:
            self.msg("Current line number in source file")
        elif 'locals'.startswith(cmd) and len(cmd) > 1:
            self.msg("Local variables of current stack frame")
        elif 'program'.startswith(cmd):
            self.msg("Execution status of the program")
        elif 'source'.startswith(cmd):
            self.msg("Information about the current Python file")
        else:
            self.undefined_cmd("help info", cmd)

    def lineinfo(self, identifier):
        failed = (None, None, None)
        # Input is identifier, may be in single quotes
        idstring = identifier.split("'")
        if len(idstring) == 1:
            # not in single quotes
            id = idstring[0].strip()
        elif len(idstring) == 3:
            # quoted
            id = idstring[1].strip()
        else:
            return failed
        if id == '': return failed
        parts = id.split('.')
        # Protection for derived debuggers
        if parts[0] == 'self':
            del parts[0]
            if len(parts) == 0:
                return failed
        # Best first guess at file to look at
        fname = self.defaultFile()
        if len(parts) == 1:
            item = parts[0]
        else:
            # More than one part.
            # First is module, second is method/class
            f = self.lookupmodule(parts[0])
            if f:
                fname = f
            item = parts[1]
        answer = find_function(item, fname)
        return answer or failed

    def forget(self):
        self.lineno = None
        self.stack = []
        self.curindex = 0
        self.curframe = None

    def interaction(self, frame, traceback):
        """Possibly goes into loop to read debugger commands."""
        do_loop = self.setup(frame, traceback) != 1
        if do_loop:
            if frame:
                self.print_location(print_line=self.linetrace)
                self.display.displayAny(self.curframe)
            if not self.noninteractive:
                try:
                    self.cmdloop()
                except KeyboardInterrupt:
                    self.do_quit(None)
        self.currentbp = None    # Can forget it now that we're moving on
        self.forget()
        if not do_loop:
            # Tell cmdloop to break out of its loop.
            return True 

    def set_helper(self, cmd, label=False):
        """Show help for a single set subcommand"""
        if label:
            self.msg_nocr("set %s --" % cmd)
        if 'args'.startswith(cmd):
            self.msg("Set argument list to give program being debugged when it is started")
        elif 'basename'.startswith(cmd):
            self.msg("Set short filenames (the basename) in debug output")
        elif 'cmdtrace'.startswith(cmd):
            self.msg("Set to show lines read from the " +
                     "debugger command file")
        elif 'history'.startswith(cmd):
            self.msg("Generic command for setting command history parameters")
        elif 'interactive'.startswith(cmd):
            self.msg("Set whether we are interactive")
        elif 'linetrace'.startswith(cmd) and len(cmd) > 2:
            self.msg("Set line execution tracing and delay on tracing")
        elif 'listsize'.startswith(cmd) and len(cmd) > 2:
            self.msg("Set number of source lines the debugger will list "
                     + "by default")
        elif 'logging'.startswith(cmd) and len(cmd) > 1:
            self.msg("Set logging options")
        elif 'prompt'.startswith(cmd):
            self.msg("Set debugger's prompt")
        else:
            self.undefined_cmd("help set", cmd)

    def setup(self, frame, traceback=None):
        """Initialization done before entering the debugger-command
        loop. We return 1 if we should NOT enter the debugger-command
        loop."""
        self.forget()
        if frame:
            self.stack, self.curindex = self.get_stack(frame, traceback)
            self.curframe = self.stack[self.curindex][0]
        else:
            self.stack = self.curframe = self.botframe = None
        if self.execRcLines()==1: return 1

    def setup_source(self, arg, showError=False):
        """Set up to read commands from a source file"""
        try:
            rcFile = open(os.path.join(arg))
        except IOError, (errno, strerror):
            if showError:
                self.errmsg("Error opening debugger command file %s: %s"
                            % (arg, strerror))
            pass
        else:
            for line in rcFile.readlines():
                self.rcLines.append(line)
            rcFile.close()

    def show_commands(self, arg):
        """Show the history of commands you typed.
You can supply a command number to start with, or a `+' to start after
the previous command number shown. A negative number starts from the end."""
        try:
            import @READLINE@
            if self.histfile is not None:
                hist_max = readline.get_current_history_length()
                if arg is None:
                    first=1
                    self.hist_last=hist_max
                else:
                    if arg == '+':
                        first = self.hist_last+1
                        self.hist_last = min(hist_max,
                                             first + self.listsize)
                    else:
                        try: 
                            center = self.get_int(arg,
                                                  cmdname="show commands")
                        except ValueError:
                            return
                        if center < 0: center = hist_max + center + 1
                        first = max(1, center - (self.listsize/2))
                        self.hist_last = min(hist_max,
                                             center + (self.listsize/2))
                i=first
                while i<=self.hist_last:
                    self.msg("%5d  %s" % (i, readline.get_history_item(i)))
                    i += 1
            else:
                self.errmsg("History mechanism turned off.")
        except ImportError:
            self.errmsg("Readline not available.")
            
    def write_history_file(self):
        """Write the command history file -- possibly."""
        if self.hist_save:
            try:
                import @READLINE@
                try:
                    readline.write_history_file(self.histfile)
                except IOError:
                    pass
            except ImportError:
                pass

    ###################################################################
    # Command definitions, called by cmdloop()
    # The argument is the remaining string on the command line
    # Return true to exit from the command loop
    ###################################################################

    def do_alias(self, arg):
        """alias [name [command [parameter parameter ...] ]]
Creates an alias called 'name' the executes 'command'.  The command
must *not* be enclosed in quotes.  Replaceable parameters are
indicated by %1, %2, and so on, while %* is replaced by all the
parameters.  If no command is given, the current alias for name
is shown. If no name is given, all aliases are listed.

Aliases may be nested and can contain anything that can be
legally typed at the debugger prompt.  Note!  You *can* override
internal debugger commands with aliases!  Those internal commands
are then hidden until the alias is removed.  Aliasing is recursively
applied to the first word of the command line; all other words
in the line are left alone.

Some useful aliases (especially when placed in the .%src file) are:

#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]

#Print instance variables in self
alias ps pi self
""" % _debugger_name
        args = arg.split()
        if len(args) == 0:
            keys = self.aliases.keys()
            keys.sort()
            for alias in keys:
                self.msg("%s = %s" % (alias, self.aliases[alias]))
            return
        if args[0] in self.aliases and len(args) == 1:
            self.msg("%s = %s" % (args[0], self.aliases[args[0]]))
        else:
            self.aliases[args[0]] = ' '.join(args[1:])

    def do_break(self, arg, temporary = 0):
        """b(reak) {[file:]lineno | function} [, condition]
With a line number argument, set a break there in the current
file.  With a function name, set a break at first executable line
of that function.  Without argument, list all breaks.  If a second
argument is present, it is a string specifying an expression
which must evaluate to true before the breakpoint is honored.

The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that
hasn't been loaded yet).  The file is searched for on sys.path;
the .py suffix may be omitted."""
        if not self.curframe:
            self.msg("No stack.")
            return
        cond = None
        funcname = None
        if not arg:
            if self.lineno is None:
                lineno = max(1, inspect.getlineno(self.curframe))
            else:
                lineno = self.lineno + 1
            filename = self.curframe.f_code.co_filename
        else:
            # parse arguments; comma has lowest precedence
            # and cannot occur in filename
            filename = None
            lineno = None
            comma = arg.find(',')
            if comma > 0:
                # parse stuff after comma: "condition"
                cond = arg[comma+1:].lstrip()
                arg = arg[:comma].rstrip()
            (funcname, filename, lineno) = self.__parse_filepos(arg)
            if lineno is None: return
            
        # FIXME This default setting doesn't match that used in
        # do_clear. Perhaps one is non-optimial.
        if not filename:
            filename = self.defaultFile()

        # Check for reasonable breakpoint
        line = checkline(self, filename, lineno)
        if line:
            # now set the break point
            # Python 2.3.5 takes 5 args rather than 6.
            # There is another way in configure to test for the version,
            # but this works too.
            try:
               err = self.set_break(filename, line, temporary, cond, funcname)
            except TypeError:
               err = self.set_break(filename, line, temporary, cond)

            if err: self.errmsg(err)
            else:
                bp = self.get_breaks(filename, line)[-1]
                self.msg("Breakpoint %d set in file %s, line %d."
                         % (bp.number, self.filename(bp.file), bp.line))

    do_b = do_break

    def do_cd(self, arg):
        """Set working directory to DIRECTORY for debugger and program
        being debugged. """
        if not arg:
            self.errmsg("Argument required (new working directory).")
        else:
           os.chdir(arg)

    def do_clear(self, arg):
        """cl(ear) {[file:]linenumber | function}

        Clear breakpoint at specified line or function.  Argument may
        be line number, function name, or '*' and an address.  If line
        number is specified, all breakpoints in that line are cleared.
        If function is specified, breakpoints at beginning of function
        are cleared.  If an address is specified, breakpoints at that
        address are cleared.

        With no argument, clears all breakpoints in the line that the
        selected frame is executing in.

        See also the 'delete' command which clears breakpoints by number.
        """

        if not self.curframe:
            self.msg("No frame selected.")
            return
        if not arg:
            frame, lineno = self.stack[self.curindex]
            filename = self.canonic_filename(self.curframe)

        else:
            if ':' in arg:
                # Make sure it works for "clear C:\foo\bar.py:12"
                i = arg.rfind(':')
                filename = arg[:i]
                arg = arg[i+1:]
                try:
                    lineno = int(arg)
                except:
                    self.errmsg("Invalid line number (%s)" % arg)
                    return
            else:
                (funcname, filename, lineno) = self.__get_brkpt_lineno(arg)
                    
            if lineno is None: return

            # FIXME This default setting doesn't match that used in
            # do_break. Perhaps one is non-optimial.
            if filename is None:
                filename = self.canonic_filename(self.curframe)
                    
        brkpts = self.clear_break(filename, lineno)

        if len(brkpts) > 0:
            if len(brkpts) == 1:
                self.msg("Deleted breakpoint %d" % brkpts[0])
            else:
                self.msg("Deleted breakpoints " +
                         ' '.join(map(lambda b: str(b), brkpts)))
        return

    do_cl = do_clear

    def do_commands(self, arg):

        """Defines a list of commands associated to a breakpoint Those
        commands will be executed whenever the breakpoint causes the
        program to stop execution."""

        if not arg:
            bnum = len(bdb.Breakpoint.bpbynumber)-1
        else:
            try:
                bnum = self.get_pos_int(arg, min=0, default=None,
                                        cmdname="'commands'")
            except ValueError:
                return
        if not (bnum < len(bdb.Breakpoint.bpbynumber)):
            self.errmsg('No breakpoint numbered %d.' % bnum)
            return

        self.commands_bnum = bnum
        self.commands[bnum] = []
        self.commands_doprompt[bnum] = True
        self.commands_silent[bnum] = False

        self.commands_defining = True
        if self.setup(self.curframe) == 1:
            self.commands_defining = False
            return

        prompt_back = self.prompt
        self.prompt = '>'
        self.msg("Type commands for when breakpoint %d is hit, one per line."
                 % bnum)
        self.msg('End with a line saying just "end".')

        self.cmdloop()
        self.commands_defining = False
        self.prompt = prompt_back

    def do_condition(self, arg):
        """condition bpnumber str_condition

        str_condition is a string specifying an expression which must
        evaluate to true before the breakpoint is honored.  If
        str_condition is absent, any existing condition is removed;
        i.e., the breakpoint is made unconditional."""

        args = arg.split(' ', 1)
        try:
            bpnum = self.get_pos_int(args[0].strip(), min=1,
                                     cmdname='condition')
        except ValueError:
            return
        except IndexError:
            self.errmsg("Breakpoint number required.")
        try:
            cond = args[1]
        except:
            cond = None
        try:
            bp = bdb.Breakpoint.bpbynumber[bpnum]
        except IndexError:
            self.errmsg("No breakpoint number %d." % bpnum)
            return
        if bp:
            bp.cond = cond
            if not cond:
                self.msg('Breakpoint %d is now unconditional.' % bpnum)

    # Note: ddd only uses first line of docstring after the command name.
    # That is the part that starts Continue execution...
    # So make sure this is a complete sentence.
    def do_continue(self, arg):
        """c(ontinue)

        Continue execution; only stop when a breakpoint is encountered."""
        if not self.is_running(): return
        if self.linetrace:
            # linetracing is like stepping, but we just don't stop. If
            # we were to calling set_continue, it  *might* remove all
            # stopping if there were no breakpoints.
            self.step_ignore = -1
            self.set_step()
        else:
            self.set_continue()

        # Tell cmdloop to break out of its loop.
        return True 

    do_c = do_continue

    def do_debug(self, arg):
        """debug code
        Enter a recursive debugger that steps through the code argument
        (which is an arbitrary expression or statement to be executed
        in the current environment)."""
        if not self.curframe:
            self.msg("No frame selected.")
            return
        sys.settrace(None)
        globals = self.curframe.f_globals
        locals = self.curframe.f_locals
        from pydb import Pdb
        p = Pdb()
        p.prompt  = "(%s) " % self.prompt.strip()
        self.msg("ENTERING RECURSIVE DEBUGGER")

        # Inherit some values from current environemnt
        p.aliases         = self.aliases
        p.basename        = self.basename
        p.cmdtrace        = self.cmdtrace
        p.gdb_dialect     = self.gdb_dialect
        p.linetrace       = self.linetrace
        p.linetrace_delay = self.linetrace_delay
        p.listsize        = self.listsize
        p.noninteractive  = self.noninteractive

        # Some values that are different from the current environment
        # and different from the default initialization values.
        p.running         = True  # We *are* trying to run something
        p.step_ignore     = 1     # We need to skip one statement
        
        sys.call_tracing(p.run, (arg, globals, locals))
        self.msg("LEAVING RECURSIVE DEBUGGER")
        sys.settrace(self.trace_dispatch)
        self.lastcmd = p.lastcmd
        self.print_location()

    def do_delete(self, arg):
        """delete [bpnumber [bpnumber...]]  - Delete some breakpoints.
        Arguments are breakpoint numbers with spaces in between.  To
        delete all breakpoints, give no argument.  those breakpoints.
        Without argument, clear all breaks (but first ask
        confirmation).
        
        See also the 'clear' command which clears breakpoints by
        line/file number.."""
        if not arg:
            if get_confirmation('Delete all breakpoints (y or n)? '):
                self.clear_all_breaks()
            return

        numberlist = arg.split()
        for arg in numberlist:
            try:
                i = self.get_pos_int(arg, min=1, default=None,
                                     cmdname='delete')
            except ValueError:
                continue

            if not (i < len(bdb.Breakpoint.bpbynumber)):
                self.errmsg('No breakpoint numbered %d.' % i)
                continue
            err = self.clear_bpbynumber(i)
            if err:
                self.errmsg(err)
            else:
                self.msg('Deleted breakpoint %d' % i)

    def do_directory(self, arg):

        """Add directory DIR to beginning of search path for source
files.  Forget cached info on source file locations and line
positions.  DIR can also be $cwd for the current working directory, or
$cdir for the directory in which the source file was compiled into
object code.  With no argument, reset the search path to $cdir:$cwd,
the default."""
        args = arg.split()
        if len(args) == 0:
            if get_confirmation(
                'Reinitialize source path to empty? (y or n) '):
                self.search_path=''
            return
        else:
            # FIXME: Loop over arguments checking for directory?
            self.search_path=args[0]

    def do_disable(self, arg):
        """disable [display] bpnumber [bpnumber ...]

        Disables the breakpoints given as a space separated list of bp
        numbers."""

        args = arg.split()
        if len(args) == 0:
            self.errmsg('No breakpoint number given')
            return
        if args[0] == 'display':
            self.display_enable(args[1:], 0)
            return
        for i in args:
            try:
                i = int(i)
            except ValueError:
                self.msg('Breakpoint index %r is not a number' % i)
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                self.msg('No breakpoint numbered %d' % i)
                continue

            bp = bdb.Breakpoint.bpbynumber[i]
            if bp:
                bp.disable()

    def do_disassemble(self, arg):
        """disassemble [arg]
        With no argument disassemble at the current frame location.
        With a numeric argument, disassemble at the frame location at that
        line number. With a class, method, function, code or string argument
        disassemble that."""
        if not self.curframe:
            self.msg("No frame selected.")
            return

        # Disassemble uses "print". We may have redirected where we want
        # debugger output to go. So we'll save and restore sys.stdout.
        # Observation and fix from Matt Flemming.
        orig_stdout = sys.stdout
        sys.stdout = self.stdout
        try:
            if not arg:
                dis.disassemble(self.curframe.f_code, self.curframe.f_lasti)
            else:
                try:
                    i = int(arg)
                    dis.disassemble(self.curframe.f_code, i)
                except ValueError:
                    try: 
                        obj=self.getval(arg)
                        dis.dis(obj)
                    except NameError:
                        pass
        except:
            # Make sure we restore sys.stdout on an exception.
            sys.stdout = orig_stdout
            raise # reraise exception
        sys.stdout = orig_stdout
        
    def do_display(self, arg):
        """display [format] EXP

        Print value of expression EXP each time the program stops.
        FMT may be used before EXP and may be one of 'c' for char, 
        'x' for hex, 'o' for octal, 'f' for float or 's' for string.

        With no argument, display all currently requested auto-display
        expressions.  Use "undisplay" to cancel display requests previously
        made."""

        if not arg:
            # Display anything active
            self.display.displayAny(self.curframe)
        else:
            # Set up a display
            arglist = arg.split()
            if len(arglist) == 2:
               format, variable = arglist
            else:
               format = ""
               variable = arglist[0]
            dp = DisplayNode(self.curframe, variable, format)
            res = dp.checkValid(self.curframe)
            self.msg(res)
        return
    
    def do_down(self, arg):
        """d(own) [count]

        Move the current frame one level down in the stack trace
        (to a newer frame).

        If using gdb dialect up matches the gdb: 0 is the most recent
        frame.  Otherwise we match Python's stack: 0 is the oldest
        frame.  """

        try:
            count = self.get_int(arg, cmdname="down")
        except ValueError:
            return
        if self.gdb_dialect:
            count = -count
        self.__adjust_frame(pos=-count, absolute_pos=False)

    def do_enable(self, arg):
        """enable [display] bpnumber [bpnumber ...]]

        Enables the breakpoints given as a space separated list of bp
        numbers."""
        args = arg.split()
        if len(args) == 0:
            self.errmsg('No breakpoint number given')
            return

        if args[0] == 'display':
            self.display_enable(args[1:], True)
            return

        for i in args:
            try:
                i = int(i)
            except ValueError:
                self.msg('Breakpoint index %r is not a number' % i)
                continue

            if not (0 <= i < len(bdb.Breakpoint.bpbynumber)):
                self.errmsg('No breakpoint numbered %d' % i)
                continue

            bp = bdb.Breakpoint.bpbynumber[i]
            if bp:
                bp.enable()

    def do_examine(self, arg):
        """examine expression - Print the expression, its value, type,
        and object attributes."""
        s = print_obj(arg, self.curframe)
        self.msg(s)

    do_x = do_examine

#    def do_file(self, fname):
#
#        """ Use FILE as program to be debugged.  It is compiled and
#        becomes is the program executed when you use the `run'
#        command.  If FILE cannot be found as specified, your execution
#        directory path ($PATH) is searched for a command of that name.
#        No arg means to have no executable file and no symbols."""
#
#        if fname == "":
#            if self.mainpyfile == "":
#                print 'No exec file now.\nNo symbol file now.'
#                return
#            else:
#                # should confirm this per
#                #Discard symbol table from `/work/.../ddd/cxxtest'? (y or n) n
#                # XXX 
#                # del module
#                sys.path = self.originalpath[:]
#                self.mainpyfile == ""
#        else:
#            path, module = os.path.split(fname)
#            module = module.split('.')[0]
#            sys.path = self.originalpath[:]
#            sys.path.insert(0, path)
#            # XXX how to clean up name space ??
#            if self.moduletodebug:
#                try:
#                    # del self.moduletodebug
#                    self.moduletodebug = ''
#                except:
#                    pass
#            line = "import " + module + '\n'
#            code = compile(line, '<stdin>', 'single')
#            globals = self.curframe.f_globals
#            locals = self.curframe.f_locals
#            exec code in globals, locals
#            # Could print 'Reading symbols from fname...done.' for gdb conformance
#            self.mainpyfile = fname
#            self.moduletodebug = module

    def do_finish(self, arg):
        """finish

        Continue execution until the current function returns."""
        if not self.is_running(): return
        self.set_return(self.curframe)
        if self.linetrace:
            self.step_ignore = -1
            self.stopframe = None

        # Tell cmdloop to break out of its loop.
        return True 

    def do_frame(self, arg):
        """frame frame-number
        Move the current frame to the specified frame number. 

        If using gdb dialect up matches the gdb: 0 is the most recent
        frame.  Otherwise we match Python's stack: 0 is the oldest
        frame.

        A negative number indicates position from the other end.
        So 'frame -1' moves when gdb dialect is in effect moves
        to the oldest frame, and 'frame 0' moves to the newest frame."""

        try:
            arg = int(arg)
        except ValueError:
            self.errmsg(("The 'frame' command requires a frame number."+
                         " Got: %s") % arg)
            return

        i_stack = len(self.stack)
        if arg < -i_stack or arg > i_stack-1:
            self.errmsg('Frame number has to be in the range %d to %d' \
                  % (-i_stack, i_stack-1))
        else:
            self.__adjust_frame(pos=arg, absolute_pos=True)

    def do_ignore(self,arg):
        """ignore bpnumber count

        Sets the ignore count for the given breakpoint number.  A
        breakpoint becomes active when the ignore count is zero.  When
        non-zero, the count is decremented each time the breakpoint is
        reached and the breakpoint is not disabled and any associated
        condition evaluates to true."""
        args = arg.split()
        bpnum = int(args[0].strip())
        try:
            count = int(args[1].strip())
        except:
            count = 0
        bp = bdb.Breakpoint.bpbynumber[bpnum]
        if bp:
            bp.ignore = count
            if count > 0:
                reply = 'Will ignore next '
                if count > 1:
                    reply = reply + '%d crossings' % count
                else:
                    reply = reply + '1 crossing'
                self.msg('%s of breakpoint %d.' % (reply, bpnum))
            else:
                self.msg('Will stop next time breakpoint %d is reached.' %
                         bpnum)

    def do_info(self, arg):

        """Generic command for showing things about the program being
        debugged. You can give unique prefix of the name of a subcommand to
        get info about just that subcommand."""

        if not arg:
            self.help_info([])
            return

        arglist = arg.split()
        arg = arglist[0]
        frame=self.curframe
        if "args".startswith(arg):
            if not self.curframe:
                self.msg("No stack.")
                return
            self.__info_args(None)
        elif "break".startswith(arg):
            # FIXME: Should split out the "info" part in args
            self.do_L(None)
        elif 'display'.startswith(arg):
            if not self.display.displayAll():
                self.msg('There are no auto-display expressions now.')
        elif "globals".startswith(arg):
            if not frame:
                self.msg("No frame selected.")
                return
            self.msg("\n".join(["%s = %s"
                                % (l, pprint.pformat(self.getval(l)))
                                for l in frame.f_globals]))
        elif "line".startswith(arg) and len(arg) > 1:
            #info line identifier
            if not frame:
                self.msg("No line number information available.")
                return
            if len(arglist) == 2:
                # lineinfo returns (item, file, lineno) or (None,)
                answer = self.lineinfo(arglist[1])
                if answer[0]:
                    item, file, lineno = answer
                    if not os.path.isfile(file):
                        file = search_file(file, self.search_path,
                                           self.main_dirname)
                    self.msg('Line %s of "%s" <%s>' %
                             (lineno, file, item))
                return
            #info line
            file=self.canonic_filename(frame)
            if not os.path.isfile(file):
                file = search_file(file, self.search_path, self.main_dirname)

            self.msg('Line %d of \"%s\" at instruction %d' % 
                     (inspect.getlineno(frame),
                      self.filename(self.canonic_filename(frame)),
                     self.curframe.f_lasti))
        elif "locals".startswith(arg) and len(arg) > 1:
            if not frame:
                self.msg("No frame selected.")
                return
            self.msg("\n".join(["%s = %s"
                                % (l, pprint.pformat(self.getval(l)))
                                for l in frame.f_locals]))
        elif 'program'.startswith(arg):
            if not frame:
                self.msg("The program being debugged is not being run.")
                return
            if self.is_running():
                self.msg('Program stopped.')
                if self.currentbp:
                    self.msg('It stopped at breakpoint %d.' % self.currentbp)
                elif self.stop_reason == 'call':
                    self.msg('It stopped at a call.')
                elif self.stop_reason == 'exception':
                    self.msg('It stopped as a result of an exception.')
                elif self.stop_reason == 'return':
                    self.msg('It stopped at a return.')
                else:
                    self.msg("It stopped after stepping, next'ing or initial start.")
            return
        elif "source".startswith(arg):
            if not frame:
                self.msg("No current source file.")
                return
            self.msg('Current Python file is %s' %
                     self.filename(self.canonic_filename(frame)))
        else:
            self.undefined_cmd("info", arg)

    def info_break(self, arg):
        """info break

        Without argument, list info about all breakpoints.  With an
        integer argument, list info on that breakpoint.

        The short command name is L."""
        if self.breaks:  # There's at least one
            self.msg("Num Type          Disp Enb    Where")
            for bp in bdb.Breakpoint.bpbynumber:
                if bp:
                    self.bpprint(bp)
        else:
            self.msg("No breakpoints.")

    do_L = info_break

    def do_jump(self, arg, cmdname='Jump'):
        """jump lineno

        Set the next line that will be executed."""

        if not self.is_running():
            return

        if self.curindex + 1 != len(self.stack):
            self.errmsg("You can only jump within the bottom frame")
            return
        try:
            arg = int(arg)
        except ValueError:
            self.errmsg("The 'jump' command requires a line number.")
        else:
            try:
                # Do the jump, fix up our copy of the stack, and display the
                # new position
                self.curframe.f_lineno = arg
                self.stack[self.curindex] = self.stack[self.curindex][0], arg
                self.print_location()
            except ValueError, e:
                self.errmsg('%s failed: %s' % (cmdname, e))

    def do_list(self, arg):
        """l(ist) [- | first [last or count]]

        List source code. Without arguments, list LISTSIZE lines
        centered around the current line or continue the previous
        listing. "list -" lists LISTSIZE lines before a previous
        listing. With one argument other than "-", list LISTSIZE lines
        centered around the specified position.  With two arguments,
        list the given range; if the second argument is less than the
        first, it is a count.  First and last can be either a function
        name, a line number or file:line"""

        if not self.curframe:
            self.msg("No Python program loaded.")
            return

        self.lastcmd = 'list'
        last = None
        filename = self.curframe.f_code.co_filename
        if arg:
            if arg == '-':
                first = max(1, self.lineno - 2*self.listsize - 1)
            else:
                args = arg.split()
                (funcname, filename, first) = self.__parse_filepos(args[0])
                if first == None and funcname == None:
                    # error should have been shown previously
                    return
                if len(args) == 1:
                    first = max(1, first - (self.listsize/2))
                elif len(args) == 2:
                    (funcname, last_filename, last) = \
                               self.__parse_filepos(args[1])
                    if filename != last_filename \
                       and filename is not None and last_filename is not None:
                        self.errmsg('filename in the range must be the same')
                        return
                    if last < first:
                        try:
                            junk = int(args[1])
                            # Assume it's a count
                            last = first + last
                        except ValueError:
                            self.errmsg('2nd number (%s) is less than the '
                                        + '1st number %d is not a pure integer'
                                        % args[1], first)
                            return
                elif len(args) > 2:
                    self.errmsg('At most 2 arguments allowed. Saw: %d' %
                                len(args))
                    return
        elif self.lineno is None or not self.running:
            first = max(1, inspect.getlineno(self.curframe) - self.listsize/2)
        else:
            first = self.lineno + 1
        if last is None:
            last = first + self.listsize - 1
        breaklist = self.get_file_breaks(filename)

        # Okay we now have range information. Finally do the listing.
        # (Just when you though we'd never get around to it).
        try:
            for lineno in range(first, last+1):
                line = linecache.getline(filename, lineno)
                if not line:
                    self.msg('[EOF]')
                    break
                else:
                    s = self._saferepr(lineno).rjust(3)
                    if len(s) < 4: s = s + ' '
                    if lineno in breaklist: s = s + 'B'
                    else: s = s + ' '
                    if lineno == inspect.getlineno(self.curframe) \
                       and filename == self.curframe.f_code.co_filename:
                        s = s + '->'
                    self.msg_nocr(s + '\t' + line)
                    self.lineno = lineno
        except KeyboardInterrupt:
            pass
    do_l = do_list

    def do_next(self, arg):
        """n(ext) [count]
Continue execution until the next line in the current function is reached or it returns.

With an integer argument, perform that many times."""
        if not self.is_running(): return
        try:
            # 0 means stop now or step 1, so we subtract 1.
            self.step_ignore = self.get_pos_int(arg, default=1,
                                                cmdname='next') - 1
        except ValueError:
            return

        self.set_next(self.curframe)
        # Tell cmdloop to break out of its loop.
        return True 

    do_n = do_next

    def do_p(self, arg):
        """p expression
        Print the value of the expression."""
        try:
            self.msg(self._saferepr(self.getval(arg)))
        except:
            pass

    def do_pp(self, arg):
        """pp expression
        Pretty-print the value of the expression."""
        try:
            self.msg(pprint.pformat(self.getval(arg)))
        except:
            pass

    def do_pwd(self, arg):
        "Print working directory."
        self.msg('Working directory ' + os.getcwd() + '.')

    def do_quit(self, arg):
        """q(uit) or exit - Quit the debugger.  The program being
        executed is aborted. For now, kill is a synonym for quit."""
        self._user_requested_quit = True
        self.running              = False
        self.set_quit()

        # Tell cmdloop to break out of its loop.
        return True 

    do_kill = do_q = do_quit

    def do_restart(self, arg):
        """restart - Restart debugger and program via an exec
        call. All state is lost, and new copy of the debugger is used."""

        if self._sys_argv[0]:
            self.msg("Re exec'ing\n\t%s" % self._sys_argv)
            os.execvp(self._sys_argv[0], self._sys_argv)
        else:
            self.msg("No exectuable file specified.")
        

    def do_return(self, arg):
        """Make selected stack frame return to its caller. Control
        remains in the debugger, but when you continue execution will
        resume at the return statement found inside the subroutine or
        method.  At present we are only able to perform this if we are
        in a subroutine that has a 'return' statement in it."""
        if not self.is_running(): return
        frame = self.curframe

        if '?' == frame.f_code.co_name and not '__args__' in frame.f_locals:
            self.errmsg("I don't see that we are in a subroutine.")
            return

        while True and not self.noninteractive:
            try:
                # reply = raw_input('Make %s return now? (y or n) ')
                reply = raw_input('Return now? (y or n) ')
            except EOFError:
                reply = 'no'
                reply = reply.strip().lower()
            if reply in ('y', 'yes'):
                break
            elif reply in ('n', 'no'):
                return
            else:
                self.msg("Please answer y or n.")

        co = frame.f_code
        code = co.co_code
        labels = dis.findlabels(code)
        linestarts = dict(dis.findlinestarts(co))

        i=frame.f_lasti
        last_stmt = i
        last_line = inspect.getlineno(frame)
        # print "++i: %d, len(code): %d" % (i, len(code))
        while i < len(code):
            i += 1
            if i in labels:
                # print "++last_stmt %d" % i
                last_stmt = i
                last_line = None
            if i in linestarts and i > 0:
                # print "++last_line %d" % linestarts[i]
                last_line = linestarts[i]
            if 'RETURN_VALUE' == op_at_frame(frame, i):
                break

        if i == len(self.stack) or last_line is None:
            self.msg("Sorry; a return statement was not found.")
            return

        # print "++i: %d, last_stmt %d, line: %d " % (i, last_stmt, last_line)
        self.do_jump(last_line, "Return")

    def do_retval(self, arg):
        """retval - Show the value that is to be returned from a
function.  This command is useful after a 'finish' command or stepping
just after a 'return' statement. To change the value, make an
assignment to the variable __return__."""
        if '__return__' in self.curframe.f_locals:
            self.msg(self.curframe.f_locals['__return__'])
        else:
            self.errmg('Not yet returned!')
    do_rv = do_retval

    def do_run(self, arg):
        """run [args...]

        Run/Restart the debugged Python program. If a string is
        supplied that becomes the new command arguments.  History,
        breakpoints, actions and debugger options are preserved."""
        if not self._program_sys_argv:
            self.msg("No Python program registered.")
            # FIXME add FILE command and mention that.
            return
        if arg:
            argv_start = self._program_sys_argv[0:1]
            self._program_sys_argv = arg.split(" ")
            self._program_sys_argv[:0] = argv_start

        raise Restart

    do_R = do_run

    def do_set(self, arg):
        """See help_set"""
        args = arg.split()
        if len(args) < 2:
            self.errmsg("Expecting at least 2 arguments. Got %d" % len(args))
            return

        if   'args'.startswith(args[0]):
            self.set_args(args)
        elif 'basename'.startswith(args[0]):
            self.set_basename(args)
        elif 'cmdtrace'.startswith(args[0]):
            self.set_cmdtrace(args)
        elif 'history'.startswith(args[0]):
            self.set_history(args)
        elif 'interactive'.startswith(args[0]):
            self.noninteractive = not self.get_onoff(args[1])
        elif 'linetrace'.startswith(args[0]) and len(args[0]) > 2:
            self.set_linetrace(args)
        elif 'listsize'.startswith(args[0]) and len(args[0]) > 2:
            self.set_listsize(args)
        elif 'logging'.startswith(args[0]) and len(args[0]) > 1:
            self.set_logging(args)
        elif 'prompt'.startswith(args[0]):
            self.set_prompt(args)
        else:
            self.errmsg("unknown set subcommand %s" %  args[0])

    def do_shell(self, arg):
        """Execute the rest of the line as a shell command."""
        os.system(arg)

    def do_show(self, arg):

        """Generic command for showing things about the debugger.  You
        can give unique prefix of the name of a subcommand to get info
        about just that subcommand."""

        if not arg:
            for subcommand in self._show_cmds:
                self.msg_nocr("%s: " % subcommand)
                self.do_show(subcommand)
            return

        args = arg.split()
        if 'args'.startswith(args[0]):
            self.msg("Argument list to give program being debugged " +
                      "when it is started is ")
            self.msg('"%s".' % " ".join(self._program_sys_argv[1:]))
        elif 'basename'.startswith(args[0]):
            self.msg("basename is %s." % show_onoff(self.basename))
        elif 'cmdtrace'.startswith(args[0]) and len(args[0]) > 1:
            self.msg("cmdtrace is %s." % show_onoff(self.cmdtrace))
        elif 'commands'.startswith(args[0]) and len(args[0]) > 1:
            self.show_commands(len(args) > 1 and args[1] or None)
        elif 'directories'.startswith(args[0]):
            self.msg("Source directories searched: %s." % self.search_path)
        elif 'history'.startswith(args[0]):
            try:
                import @READLINE@
                self.msg(
"""filename:  The filename in which to record the command history is
"%s".""" % self.histfile)
                self.msg("save:  Saving of the history record on exit is %s"
                         % show_onoff(self.hist_save))
                self.msg("size:  The size of the command history is %d"
                         % readline.get_history_length())
            except ImportError:
                pass
        elif 'interactive'.startswith(args[0]):
            self.msg("interactive is %s." %
                     show_onoff(not self.noninteractive))
        elif arg == 'linetrace':
            self.msg("line tracing is %s." % show_onoff(self.linetrace))
        elif self._re_linetrace_delay.match(arg):
            self.msg("line trace delay is %s. (In seconds)"
                     % self.linetrace_delay)
        elif 'listsize'.startswith(args[0]) and len(args[0]) > 2:
            self.msg("Number of source lines %s will list by default is %d." \
                  % (_debugger_name, self.listsize))
        elif 'logging'.startswith(args[0]) and len(args[0]) > 2:
            self.show_logging(args)
        elif 'prompt'.startswith(args[0]):
            self.msg("""%s's prompt is "%s".""" %
                     (_debugger_name, self.prompt))
        elif 'version'.startswith(args[0]):
            self.msg("""%s version %s.""" %
                     (_debugger_name, "@PACKAGE_VERSION@"))
        else:
            self.undefined_cmd('show', args[0])

    def do_source(self, arg):
        """source FILE
        Read commands from a file named FILE.
        Note that the file '.@PACKAGE_NAME@rc' is read automatically
        in this way when @PACKAGE_NAME@ is started.

        An error in any command terminates execution of the command
        file and control is returned to the console."""
        self.setup_source(os.path.expanduser(arg), True);
        rc = self.execRcLines() 
        if rc == 1:  return rc

    def do_step(self, arg):
        """s(tep) [count]
Execute the current line, stop at the first possible occasion
(either in a function that is called or in the current function).

With an integer argument, step that many times."""
        if not self.is_running(): return
        try:
            # 0 means stop now or step 1, so we subtract 1.
            self.step_ignore = self.get_pos_int(arg, default=1,
                                                cmdname='step') - 1
        except ValueError:
            return

        self.set_step()
        # Tell cmdloop to break out of its loop.
        return True 

    do_s = do_step

    def do_tbreak(self, arg):
        """tbreak  [ ([filename:]lineno | function) [, condition] ]
        Set a temporary breakpoint. Arguments are like the "break" command.
        Like "break" except the breakoint is only temporary, 
        so it will be deleted when hit."""
        self.do_break(arg, 1)

    def do_unalias(self, arg):
        """unalias name
Deletes the specified alias."""
        args = arg.split()
        if len(args) == 0: return
        if args[0] in self.aliases:
            del self.aliases[args[0]]

    # Print a traceback starting at the top stack frame.
    # The most recently entered frame is printed last;
    # this is different from dbx and gdb, but consistent with
    # the Python interpreter's stack trace.
    # It is also consistent with the up/down commands (which are
    # compatible with dbx and gdb: up moves towards 'main()'
    # and down moves towards the most recent stack frame).

    def do_undisplay(self, arg):
        """Cancel some expressions to be displayed when program stops.
        Arguments are the code numbers of the expressions to stop displaying.
        No argument means cancel all automatic-display expressions.
        "delete display" has the same effect as this command.
        Do "info display" to see current list of code numbers."""

        if arg:
            args = arg.split()
            for i in args:
                try:
                    i = int(i)
                    self.display.deleteOne(i)
                except ValueError:
                    self.errmsg('index %r is not a number' % i)
        else:
            self.display.deleteAll()

    def do_up(self, arg):
        """up [count]
        Move the current frame one level up in the stack trace
        (to an older frame).
        
        If using gdb dialect up matches the gdb: 0 is the most recent
        frame.  Otherwise we match Python's stack: 0 is the oldest
        frame.  """

        try:
            count = self.get_int(arg, cmdname="up")
        except ValueError:
            return
        if self.gdb_dialect:
            count = -count
        self.__adjust_frame(pos=count, absolute_pos=False)

    def do_whatis(self, arg):
        """whatis arg
Prints the type of the argument which can be a Python expression."""
        try:
            if not self.curframe:
                # ?? Should we have set up a dummy globals
                # to have persistence? 
                value = eval(arg, None, None)
            else:
                value = eval(arg, self.curframe.f_globals,
                             self.curframe.f_locals)
        except:
            t, v = sys.exc_info()[:2]
            if type(t) == types.StringType:
                exc_type_name = t
            else: exc_type_name = t.__name__
            if exc_type_name == 'NameError':
                self.errmsg("Name Error: %s" % arg)
            else:
                self.errmsg("%s: %s" % (exc_type_name, self._saferepr(v)))
            return
        if inspect.isfunction(value):
            self.msg('function %s%s' %
                     (value.func_code.co_name,
                       inspect.formatargspec(inspect.getargspec(value))))
            if inspect.getdoc(value):
                self.msg('%s:\n%s' %
                         (value, inspect.getdoc(value)))
                return
        elif inspect.getdoc(value):
            self.msg('%s:\n%s' %
                     (value, inspect.getdoc(value)))
            return
        # None of the above...
        self.msg(type(value))

    def do_where(self, arg):
        """where [count]

        Print a stack trace, with the most recent frame at the top.
        With a positive number, print at most many entries.
        An arrow indicates the 'current frame', which determines the
        context of most commands.  'bt' and 'T' are short command
        names for this."""

        try:
            count = self.get_pos_int(arg, default=None, cmdname="where")
        except ValueError:
            return

        if not self.curframe:
            self.msg("No stack.")
            return
        print_stack_trace(self, count)

    do_T = do_bt = do_where

    def do_EOF(self, arg):
        """EOF
Handles the receipt of EOF as a command."""
        self.msg("")
        self._user_requested_quit = True
        self.set_quit()

        # Tell cmdloop to break out of its loop.
        return True 

    #########################################################
    # Help methods (derived from @PACKAGE@.doc or vice versa)
    #########################################################

    for fn in ('EOF',     'L',         'alias',       'break',
               'cd',      'clear',     'condition',   'continue',
               'debug',   'disable',   'delete'   ,   'disassemble',
               'display', 'down',      'enable',      'examine',
               'finish',  'frame',     'help',
               'ignore',  'info',      'jump',        'list',
               'next',    'p',         'pp',          'pwd',    'quit',
               'restart', 'retval',    'run',
               'set',     'show',      'shell',       'source', 'step', 
               'tbreak',  'unalias',   'undisplay',   'up',
               'whatis',  'where'):
        exec 'def help_%s(self, *arg): self.msg(getattr(self.do_%s, "__doc__"))' \
             % (fn, fn)

    # Is this the right way to do this? 
    help_h = help_help
    help_R = help_run
    help_bt = help_T = help_where

    def help_commands(self, *arg):
        print """commands [bpnumber]
>...
>end
(Pydb)

Set commands to be executed when a breakpoint is hit.
Give breakpoint number as the argument after "commands".
With no bpnumber argument, commands refers to the last one set.
The commands themselves follow starting on the next line.
Type a line containing "end" to terminate the commands.

To remove all commands from a breakpoint, type commands and
follow it immediately with end; that is, give no commands.

You can use breakpoint commands to start your program up
again. Simply use the continue command, or step, or any other
command that resumes execution.

Specifying any command resuming execution (currently continue, step,
next, return, jump, and quit) terminates the command list as if that
command was immediately followed by 'end'.  This is because any time
you resume execution (even with a simple next or step), you may
encounter another breakpoint--which could have its own command list,
leading to ambiguities about which list to execute.

If you use the 'silent' command in the command list, the
usual message about stopping at a breakpoint is not printed.
This may be desirable for breakpoints that are to print a
specific message and then continue.  If none of the other
commands print anything, you see no sign that the breakpoint
was reached.
"""

    def help_exec(self, *arg):
        self.msg("""(!) statement
        Execute the (one-line) statement in the context of
        the current stack frame.
        The exclamation point can be omitted unless the first word
        of the statement resembles a debugger command.
        To assign to a global variable you must always prefix the
        command with a 'global' command, e.g.:
        %sglobal list_options; list_options = ['-l']
        %s""" % (self.prompt, self.prompt))

    # Note: format of help is compatible with ddd.
    def help_info(self, *args):
        """Generic command for showing things about the program being debugged."""
        self.subcommand_help('info', getattr(self, 'help_info').__doc__,
                             self._info_cmds, self.info_helper, args[0])

    def help_pydb(self, *arg):
        help()

    # Note: format of help is compatible with ddd.
    def help_set(self, *args):
        """This command modifies parts of the debugger environment.
You can see these environment settings with the 'show' command."""
        self.subcommand_help('set', getattr(self, 'help_set').__doc__,
                             self._set_cmds, self.set_helper, args[0])

    # Note: format of help is compatible with ddd.
    def help_show(self, *args):
        """Generic command for showing things about the debugger."""
        self.subcommand_help('show', getattr(self, 'help_show').__doc__,
                             self._show_cmds, self.__help_show, args[0])

    def help_unalias(self):
        print """unalias name
Deletes the specified alias."""

    ####### End of help section ########
#
# Local variables:
#  mode: Python
# End:
